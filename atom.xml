<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qssq的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qingshui3000.github.io/"/>
  <updated>2020-01-05T08:47:09.896Z</updated>
  <id>https://qingshui3000.github.io/</id>
  
  <author>
    <name>qssq</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程学习总结</title>
    <link href="https://qingshui3000.github.io/2020/01/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://qingshui3000.github.io/2020/01/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-05T08:45:27.000Z</published>
    <updated>2020-01-05T08:47:09.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程学习笔记"><a href="#Java多线程学习笔记" class="headerlink" title="Java多线程学习笔记"></a>Java多线程学习笔记</h1><h2 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h2><a id="more"></a><h3 id="1-最大化的利用硬件性能"><a href="#1-最大化的利用硬件性能" class="headerlink" title="1.最大化的利用硬件性能"></a>1.最大化的利用硬件性能</h3><p>多物理核心和线程的CPU早已大量普及，显然并发的执行任务能更好的发挥硬件性能；</p><h3 id="2-设计优势"><a href="#2-设计优势" class="headerlink" title="2.设计优势"></a>2.设计优势</h3><p><strong>示例场景：</strong>有两个任务需执行，任务一假定耗时10单位，任务二假定耗时1单位时间（实际中可能并不能在执行前确定任务耗时），如果不是多线程的环境下按顺序执行任务，则总耗时11，任务二虽然仅需要1单位时间执行，却要等待前面的任务一执行完后才被执行；而在多线程下执行时，因为cpu会在当前线程的时间片消耗完后切换至其他线程，所以虽然总耗时未变，但任务二无需等待任务一彻底执行完后再执行了。</p><p><strong>总结：多线程并不会提高程序的执行速度，因为上下文切换的原因，反而会降低速度。但如上述场景描述，可以减少用户的等待响应时间，提高了资源的利用效率和用户体验。</strong></p><h3 id="3-使用多线程带来的问题"><a href="#3-使用多线程带来的问题" class="headerlink" title="3.使用多线程带来的问题"></a>3.使用多线程带来的问题</h3><p>在并发编程时会出现数据的安全问题，线程与线程之间的竞争也会导致线程死锁和<em>锁死</em> 等<strong>活性故障</strong>，还有就是上文提到的上下文切换带来的额外开销。</p><p><a href=""https://blog.csdn.net/sinat_25991865/article/details/87949199"">关于线程锁死</a></p><h2 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h2><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">"继承Thread类创建线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread1 thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继承Thread类创建线程</span><br></pre></td></tr></table></figure><h3 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现Runnable接口创建线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable myThread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myThread2);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现Runnable接口创建线程</span><br></pre></td></tr></table></figure><p><strong>两种方法有何区别？</strong></p><p>两者实现的功能是一致的，继承Thread类创建线程在设计上有局限性，因为Java不支持多继承，在一些业务情景下方法1会无法继承Thread类，而通过将一实现了Runnable接口的类作为Thread的构造方法的参数可以在保留原有继承关系的情况下创建线程。因此，总体来说，实现Runnable接口的方法创建线程更好一些，1是Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；2是类可能只要求可执行就行，继承整个 Thread 类开销过大。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><strong>jdk1.8源码中对于Thread状态的枚举定义:</strong></p><h4 id="1-新建-NEW"><a href="#1-新建-NEW" class="headerlink" title="1.新建(NEW)"></a>1.新建(NEW)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br></pre></td></tr></table></figure><p>线程还未调用start()方法启动</p><h4 id="2-可运行-RUNNABLE"><a href="#2-可运行-RUNNABLE" class="headerlink" title="2.可运行(RUNNABLE)"></a>2.可运行(RUNNABLE)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment"> * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment"> * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment"> * such as processor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RUNNABLE,</span><br></pre></td></tr></table></figure><p>正在Java虚拟机中运行，但是在操作系统的层面有两种可能，一是处于运行状态，二是等待系统资源，资源调度完成后就开始运行，所以该状态指的是<strong>可被运行</strong>，具体有没有运行要结合操作系统资源调度的情况。</p><h4 id="3-阻塞-BLOCK"><a href="#3-阻塞-BLOCK" class="headerlink" title="3.阻塞(BLOCK)"></a>3.阻塞(BLOCK)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment"> * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment"> * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment"> * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BLOCKED,</span><br></pre></td></tr></table></figure><p>在线程准备进入synchronized同步块或者方法时需要请求获取一个监听器锁(monitor lock)，若此时其他线程已经占用了该监听器锁，则当前线程进入阻塞状态；在其他线程释放了该监听器锁后当前线程结束阻塞态。</p><h4 id="4-无限期等待-WAITING"><a href="#4-无限期等待-WAITING" class="headerlink" title="4.无限期等待(WAITING)"></a>4.无限期等待(WAITING)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment"> * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment"> * following methods:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment"> * perform a particular action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment"> * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WAITING,</span><br></pre></td></tr></table></figure><p>无期限的等待其他线程显式的唤醒。与阻塞态不同的是，阻塞是被动的，它在等待获取监听器锁，而等待是主动的，通过调用Object.wait()进入；</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h4 id="5-限期等待-TIMED-WAITING"><a href="#5-限期等待-TIMED-WAITING" class="headerlink" title="5.限期等待(TIMED_WAITING)"></a>5.限期等待(TIMED_WAITING)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment"> * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment"> * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TIMED_WAITING,</span><br></pre></td></tr></table></figure><p>与上一状态类似，但在一定时间后会被系统唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h4 id="6-死亡-TERMINATED"><a href="#6-死亡-TERMINATED" class="headerlink" title="6.死亡(TERMINATED)"></a>6.死亡(TERMINATED)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死亡态就是线程执行结束(run方法执行结束)或抛出异常而结束。</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>待更。。。</p><h2 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h2><h3 id="1-中断"><a href="#1-中断" class="headerlink" title="1.中断"></a>1.中断</h3><p><strong>interrupt()</strong></p><p><strong>interrupted()</strong></p><p><strong>isInterrupted()</strong></p><h3 id="2-sleep-和wait"><a href="#2-sleep-和wait" class="headerlink" title="2.sleep() 和wait()"></a>2.sleep() 和wait()</h3><ul><li><strong>sleep方法</strong>是Thread类的静态方法，作用是将当前线程顺便n毫秒，线程挂起进入阻塞态，时间到了后会解除阻塞进入可运行态，<strong>sleep方法不释放锁。</strong></li><li><strong>wait()方法</strong>是Object类的静态方法，只能在同步方法或同步块中使用，否则运行时会抛出IllegalMonitorStateException异常，调用后线程进入阻塞态，当调用notify或notifyAll方法后解除阻塞，等待<strong>重新获得互斥锁</strong>后进入可运行态，<strong>因为wait方法释放锁</strong></li></ul><h3 id="3-如何避免死锁"><a href="#3-如何避免死锁" class="headerlink" title="3.如何避免死锁"></a>3.如何避免死锁</h3><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>1.破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们使用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>2.破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>3.破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>4.破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><h3 id="4-多线程编程中的一些线程安全问题"><a href="#4-多线程编程中的一些线程安全问题" class="headerlink" title="4.多线程编程中的一些线程安全问题"></a>4.多线程编程中的一些线程安全问题</h3><h4 id="原子性、有序性和可见性-内存模型三大特性"><a href="#原子性、有序性和可见性-内存模型三大特性" class="headerlink" title="原子性、有序性和可见性(内存模型三大特性)"></a>原子性、有序性和可见性(内存模型三大特性)</h4><p>多线程环境下的线程安全主要体现在<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>方面。</p><p><strong>1.原子性</strong></p><p>Java内存模型为read、load、use、assign、store、write、lock和unlock操作保证了<strong>原子性</strong>；<strong>特殊的</strong>，对于long和double类型的数据，Java内存模型允许虚拟机将没有被volatile关键字修饰的64位变量的读、写操划分为两次对32位数据的操作进行，即在这种情况下，read、load、store、write操作可以不具有原子性。</p><p><strong>定义</strong></p><p>对于涉及到访问共享变量的操作，若当前操作是不可拆分的，即中间操作对于线程外部来说不可见，那么该操作就是原子操作1，该操作具有原子性。</p><p><strong>举例</strong></p><p>银行业务中的转账操作，A给B转账100元，基本步骤就是A账户减少100元，B账户就会多100元，虽然表面上可以拆分为这两步，但是我们不可能看到A账户少了100元、但B账户余额并未增加的情况。（现实中可能有延迟时间，这里忽略）</p><p><strong>如何保证原子性</strong></p><ul><li>利用<strong>互斥锁</strong>的排他性，保证同一时刻只有一个线程在操作共享变量。</li><li>利用CAS保证。</li></ul><p><strong>2.可见性</strong></p><p><strong>定义</strong></p><p>可见性是指一个线程对于共享变量的更新，对于后续访问该变量的线程是否可见的问题；Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">处理器缓存的概念</span><br><span class="line"></span><br><span class="line">现代处理器处理速度远大于主内存的处理速度，所以在主内存和处理器之间加入了寄存器，高速缓存，写缓冲器以及无效化队列等部件来加速内存的读写操作。也就是说，我们的处理器可以和这些部件进行读写操作的交互，这些部件可以称为处理器缓存。</span><br><span class="line"></span><br><span class="line">处理器对内存的读写操作，其实仅仅是与处理器缓存进行了交互。一个处理器的缓存上的内容无法被另外一个处理器读取，所以另外一个处理器必须通过缓存一致性协议来读取的其他处理器缓存中的数据，并且同步到自己的处理器缓存中，这样保证了其余处理器对该变量的更新对于另外处理器是可见的。</span><br></pre></td></tr></table></figure><p><strong>如何实现可见性</strong></p><ul><li>volatile关键字</li><li>synchronized，对一个变量执行unlock操作前，必须把变量值同步回主内存。</li><li>final关键字，被final关键字修饰的字段在构造器中一旦初始化完成，并且没有发生this逃逸（其他线程通过this引用到初始化一半的变量），那么其他线程就能看到该final字段的值。</li></ul><p><strong>3.有序性</strong></p><p><strong>定义：</strong>有序性是指一个处理器上运行的线程所执行的内存访问操作在另外一个处理器上运行的线程来看是否有序的问题。</p><p><strong>重排序：</strong><br>为了提高程序执行的性能，Java编译器在其认为不影响程序正确性的前提下，可能会对源代码顺序进行一定的调整，导致程序运行顺序与源代码顺序不一致。</p><p>重排序是对内存读写操作的一种优化，在单线程环境下不会导致程序的正确性问题，但是多线程环境下可能会影响程序的正确性。</p><p><strong>重排序举例：</strong><br><strong>Instance instance = new Instance()都发生了啥？</strong><br><strong>具体步骤如下所示三步：</strong></p><ul><li>在堆内存上分配对象的内存空间</li><li>在堆内存上初始化对象</li><li>设置instance指向刚分配的内存地址</li></ul><p>第二步和第三步可能会发生重排序，导致引用型变量指向了一个不为null但是也不完整的对象。（<strong>在多线程下的单例模式中，我们必须通过volatile来禁止指令重排序</strong>）</p><p><strong>总结：</strong></p><ul><li><strong>原子性</strong>是一组操作要么完全发生，要么没有发生，其余线程不会看到中间过程的存在。注意，<strong>原子操作+原子操作不一定还是原子操作。</strong></li><li><strong>可见性</strong>是指一个线程对共享变量的更新<strong>对于另外一个线程是否可见</strong>的问题。</li><li><strong>有序性</strong>是指一个线程对共享变量的更新在其余线程看起来是<strong>按照什么顺序执行</strong>的问题。</li><li>可以这么认为，<strong>原子性 + 可见性 -&gt; 有序性</strong></li></ul><h3 id="5-互斥同步"><a href="#5-互斥同步" class="headerlink" title="5.互斥同步"></a>5.互斥同步</h3><p>Java提供了两种锁机制来控制多个线程对于共享资源的互斥访问，一个是JVM实现的synchronized关键字，另一个是JDK实现的ReentrantLock</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul><li><strong>同步代码块</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只作用于同一个对象，如果分别调用两个对象上的同步代码块，就不会进行同步</strong></p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例1（同一个对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>示例2（两个对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li><strong>同步方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与同步块一样，作用于同一个对象</p><ul><li><strong>同步一个类</strong></li></ul><p>作用于整个类，也就是两个线程调用同一个类的不同对象的同步语句仍会进行同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><ul><li><strong>同步静态方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类</p><h4 id="ReentrantLock和synchronized的区别"><a href="#ReentrantLock和synchronized的区别" class="headerlink" title="ReentrantLock和synchronized的区别"></a>ReentrantLock和synchronized的区别</h4><p>ReentrantLock<strong>是显示锁</strong>，其提供了一些内部锁不具备的特性，但并不是内部锁的替代品。<strong>显式锁支持公平和非公平的调度方式</strong>，默认采用非公平调度。</p><p>synchronized 内部锁简单，但是不灵活。显示锁支持在一个方法内申请锁，并且在另一个方法里释放锁。<strong>显示锁定义了一个tryLock（）方法，尝试去获取锁</strong>，成功返回true，失败并不会导致其执行的线程被暂停而是直接返回false，即可以<strong>避免死锁</strong>。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><strong>1. 锁的实现</strong></p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="1-使用线程池的好处"><a href="#1-使用线程池的好处" class="headerlink" title="1.使用线程池的好处"></a>1.使用线程池的好处</h3><p>线程池和Http连接池、数据库连接池等类似，都是为了降低资源消耗、提高访问效率。</p><p><strong>使用线程池的好处：</strong></p><ul><li><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度。</strong>当任务到达时，任务可以<strong>不需要等待线程创建</strong>就能立即执行。</li><li><strong>提高线程的可管理性。</strong>线程是一种稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。</li></ul><h3 id="2-ThreadPoolExecutor"><a href="#2-ThreadPoolExecutor" class="headerlink" title="2.ThreadPoolExecutor"></a>2.ThreadPoolExecutor</h3><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><p>线程池实现类是Executor框架最核心的类</p><p><code>ThreadPoolExecutor</code>的3个重要参数：</p><ul><li><code>corePoolSize</code>：核心线程数，定义了最小可以同时运行的线程数量。</li><li><code>maximumPoolSize</code>：最大线程数。</li><li><code>workQueue</code>：存储线程的队列</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><h4 id="线程池的排队策略："><a href="#线程池的排队策略：" class="headerlink" title="线程池的排队策略："></a>线程池的排队策略：</h4><ul><li>如果正在运行的线程数小于核心线程数，则Executor始终首选添加新的线程进入线程池，而不排队。</li><li>如果正在运行的线程等于或多余核心线程数，则Executor始终首选将新请求加入队列进行排队。</li><li>如果无法将请求加入队列，即队列已满，则创建新的线程，若创建此线程后超出<code>maximumPoolSize</code>，则任务将会拒绝。</li></ul><h4 id="常见的线程池类型"><a href="#常见的线程池类型" class="headerlink" title="常见的线程池类型"></a>常见的线程池类型</h4><p><strong>newCachedThreadPool()</strong></p><ul><li>核心线程池大小为0，最大线程数不受限，即每次请求都会创建一个线程。</li><li>适合用于执行大量耗时短且提交频率高的任务场景。</li></ul><p><strong>newFixedThreadPool()</strong></p><ul><li>固定大小的线程池</li><li>当线程池大小达到核心线程数时，会将新任务加入<code>LinkedBlockingQueue</code>。</li><li>线程池中的线程执行完手头的任务后，会在循环中反复从<code>LinkedBlockingQueue</code>中获取任务执行。</li></ul><p><code>LinkedBlockingQueue</code>是一个无界队列（容量为Integer.MAX_VALUE）。</p><p>为什么不推荐使用<code>FixedThreadPool</code>：</p><p>1.线程池达到核心线程数后不会继续增加。</p><p>2.由于无界队列的存在，<code>maximumPoolSize</code>将会是一个无效参数，即不可能存在任务队列满的情况（<code>FixedThreadPool</code>中的<code>maximumPoolSize</code>和<code>corePoolSize</code>被设置为同一个值）。</p><p>3.同理，由于1,2，<code>keepAliveTime</code>也将会是一个无效参数。</p><p>4.由于无界队列的存在，运行中的<code>FixedThreadPoll</code>不会拒绝任务，在任务比较多的时候会导致OOM（内存溢出）。</p><p><strong>newSingleThreadExecutor()</strong></p><p>便于实现生产者-消费者模式</p><h4 id="常见的阻塞队列"><a href="#常见的阻塞队列" class="headerlink" title="常见的阻塞队列"></a>常见的阻塞队列</h4><p><strong>ArrayBlockingQueue:</strong></p><ul><li>内部使用一个<strong>数组</strong>作为其存储空间，数组的存储空间是<strong>预先分配</strong>的</li><li><strong>优点是</strong> put 和 take操作不会增加GC的负担（因为空间是预先分配的）</li><li><strong>缺点是</strong> put 和 take操作使用同一个锁，可能导致锁争用，导致较多的上下文切换。</li><li>ArrayBlockingQueue适合在生产者线程和消费者线程之间的<strong>并发程序较低</strong>的情况下使用。</li></ul><p><strong>LinkedBlockingQueue：</strong></p><ul><li>是一个无界队列（其实队列长度是Integer.MAX_VALUE）</li><li>内部存储空间是一个<strong>链表</strong>，并且链表节点所需的<strong>存储空间是动态分配</strong>的</li><li><strong>优点是</strong> put 和 take 操作使用两个显式锁（putLock和takeLock）</li><li><strong>缺点是</strong>增加了GC的负担，因为空间是动态分配的。</li><li>LinkedBlockingQueue适合在生产者线程和消费者线程之间的并发程序较高的情况下使用。</li></ul><p><strong>SynchronousQueue：</strong><br>SynchronousQueue可以被看做一种特殊的有界队列。生产者线程生产一个产品之后，会等待消费者线程来取走这个产品，才会接着生产下一个产品，适合在生产者线程和消费者线程之间的处理能力相差不大的情况下使用。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每个线程都可以拥有独立的副本，不会影响到其他线程的变量副本。</p><p>ThreadLocal类用于实现<strong>线程的本地存储</strong></p><h3 id="2-ThreadLocal内部实现机制"><a href="#2-ThreadLocal内部实现机制" class="headerlink" title="2.ThreadLocal内部实现机制"></a>2.ThreadLocal内部实现机制</h3><ul><li>每个线程内部都会维护一个类似HashMap的对象，称为<strong>ThreadLocalMap</strong>，里面会包含若干<strong>Entry(KEY-VALUE键值对)</strong>，相应的线程被称为这些Entry的属主线程。</li><li><strong>Entry的KEY是一个ThreadLocal实例，VALUE是一个线程持有对象。</strong>Entry的作用即为其属主线程建立起一个ThreadLocal实例和线程持有对象的对应关系。</li><li>Entry对KEY是弱引用，对VALUE是强引用（GC时的区别）。</li></ul><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>java.util.concurrent.atomic包下的AtomicInteger等原子类用于保证复合操作的原子性。</p><ul><li><strong>AtomicInteger类提供了getAndIncrement和incrementAndGet等原子性的自增自减等操作</strong>。</li><li><strong>Atomic等原子类内部使用了CAS来保证原子性。</strong></li></ul><h2 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h2><p>代更。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java多线程学习笔记&quot;&gt;&lt;a href=&quot;#Java多线程学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Java多线程学习笔记&quot;&gt;&lt;/a&gt;Java多线程学习笔记&lt;/h1&gt;&lt;h2 id=&quot;为什么要使用多线程&quot;&gt;&lt;a href=&quot;#为什么要使用多线程&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用多线程&quot;&gt;&lt;/a&gt;为什么要使用多线程&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://qingshui3000.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer NO.7 重建二叉树</title>
    <link href="https://qingshui3000.github.io/2019/12/28/%E5%89%91%E6%8C%87offer%20NO.7%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://qingshui3000.github.io/2019/12/28/%E5%89%91%E6%8C%87offer%20NO.7%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2019-12-28T12:30:02.000Z</published>
    <updated>2020-04-04T11:37:40.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><a id="more"></a><p><a href=""https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"">牛客网-重建二叉树</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据二叉数的前序和中序遍历构建二叉树，二叉树的前序遍历和中序遍历结果，以int数组的形式输入</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据树的前序和中序遍历规律，前序遍历的第一个结点是二叉树的根节点，在中序遍历中以根节点划分，左边就是二叉树的左子树，右边是右子树，按这个规律进行递归，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; in.length;i++)&#123;</span><br><span class="line">            map.put(in[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> construct(pre,<span class="number">0</span>,pre.length - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">construct</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> inl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[l]);</span><br><span class="line">        <span class="keyword">int</span> index = map.get(root.val);</span><br><span class="line">        <span class="keyword">int</span> lsize = index - inl;</span><br><span class="line">        root.left = construct(pre,l + <span class="number">1</span>,l + lsize,inl);</span><br><span class="line">        root.right = construct(pre,l + lsize + <span class="number">1</span>,r,inl + lsize + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;重建二叉树&quot;&gt;&lt;a href=&quot;#重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;重建二叉树&quot;&gt;&lt;/a&gt;重建二叉树&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>表达式求值</title>
    <link href="https://qingshui3000.github.io/2019/12/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <id>https://qingshui3000.github.io/2019/12/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</id>
    <published>2019-12-20T12:27:59.000Z</published>
    <updated>2019-12-20T12:52:43.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>表达式求值是栈这种数据结构的一个很经典的应用，恰逢是数据结构期末实践题目，经过一定的努力终于也是实现了这个算法，所以分享下我的思路和经验，希望正准备尝试解决这个问题的同学可以少走些弯路，有所借鉴和收获。</p><p><strong>个人水平有限，文笔拙劣，有所意见和建议欢迎指出</strong></p><a id="more"></a><p>我们日常使用的四则运算式如 1+1 被称为中缀表达式，即所有的运算符号都在运算数的中间出现，我们在初学编程时都练习过简单的二元运算，但当求值问题扩大到一个完整的四则运算式的时候，就需要考虑<strong>运算符优先级、括号</strong>等多个问题，解决了这些问题也就实现了表达式求值。</p><p>表达式求值问题常用的也是最广泛的解决方法是逆波兰式转换法，主要步骤可简单分为两步，用户输入的中缀表达式转化为后缀表达式（逆波兰式），再对逆波兰式进行运算。但在编程过程中我发现简单的分为两步是行不通的，因为涉及到多位数和浮点数，由于输入时统一存储为字符串，在进行中缀到后缀的转换后无法得到正确的后缀式字符串，由于c语言中char型数据实际上也是int型数据，这就进一步增加了正确转换的难度，从而也就无法在逆波兰式的计算中得出正确的结果，所以在编程实现时将这两步合为一个函数实现，<strong>即以字符串形式存储键盘输入的表达式后，对该字符串逐位处理，通过ASCII码值的判断分为数字或小数点、运算符两种情况，然后按照判断结果执行相应的语句。</strong></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>创建<strong>一char型数组</strong>用于存储输入的中缀表达式，在中缀表达式向后缀表达式的转化以及后缀表达式的计算中（<strong>详情见各种数据结构教材或书籍，或相关博客，实现此算法必须要实现了解这些过程</strong>）我们知道，因为涉及到运算符优先级的判断和后缀表达式的计算的部分我们需要借助栈来实现，所以需要创建<strong>一double型栈和一char型栈</strong>，分别用于存储操作数和运算符，栈的存储可随意选用线性结构或链式结构，需要实现以下操作函数：</p><ul><li>初始化</li><li>出栈</li><li>入栈</li><li>取栈顶</li><li>判空</li></ul><p>接下来对如何处理输入的表达式做详细介绍</p><h3 id="1-数字或小数点（非运算符）"><a href="#1-数字或小数点（非运算符）" class="headerlink" title="1.数字或小数点（非运算符）"></a>1.数字或小数点（非运算符）</h3><p><img src="/images/ascii.png" alt="ascii">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上图为ASCII码对照表</p><p>通过ASCII码我们可以得出输入的是数字（0-9）的条件，但因为存在多位数的情况，所以当前数字可能是输入的操作数的十位或百位等，所以不能简单的压入数字栈就完事，我的解决方法是每当遇到数字位都进行一次判断，检查表达式字符串中它的前一位是否为数字，若是，则说明这是个多位数，则将前一位（已入栈）出栈与10的n次幂做乘积后与当前位求和再入栈；对于例如12.34这类浮点数，则在判断当前位不是运算符后首先检查是否为小数点，若是则说明直到下一个运算符都是该浮点数的小数位，则与求多位整数（例12.34的整数位）值类似，与10的负n次幂做乘积累加求和知道遇到下一个运算符时入栈。</p><p><img src="/images/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%AD%90%E5%9B%BE2.png" alt="表达式求值子图2">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上图是我做的流程图（第一次做，略丑，希望能帮助理解即可）</p><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><p>运算符的处理相对于操作数就简单许多了，唯一的小问题就是运算符优先级的判断，我第一次写的时候写了层层嵌套的if和switch语句，做了简化修改后可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line"><span class="comment">//判定运算符的栈顶运算符与读入的运算符之间优先关系</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">switch</span>(c1)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">switch</span>(c2)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">    c=<span class="string">'&gt;'</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    c=<span class="string">'&lt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">if</span>(c2==<span class="string">'('</span>)&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="string">')'</span>)&#123;</span><br><span class="line">c=<span class="string">'='</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">    c=<span class="string">'&gt;'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="string">'#'</span>)&#123;</span><br><span class="line">c=<span class="string">'='</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>解决了优先级的判断问题后，根据中缀转后缀的步骤，优先级高于栈顶入栈，低的出栈运算直到栈顶元素优先级低于当前位，思路如下：<img src="/images/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%AD%90%E5%9B%BE3.png" alt="表达式求值子图3">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如上所述，对表达式字符串处理完毕后，此时运算结果其实就是操作数栈的栈顶元素，且操作数栈仅剩该数字，输出即可。</p><p>下面是完整代码和流程图，如果文字描述不足以让你彻底明白这个问题的解决方法，希望能静下心多看看代码，愿你能保持学习的热情</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zhao6582@qq.com 12/18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="comment">//double栈，用于存放运算数 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;Stack_n;</span><br><span class="line"><span class="comment">//char栈，用于存放运算符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;Stack_c;</span><br><span class="line"><span class="comment">//栈的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_n</span><span class="params">(Stack_n s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_c</span><span class="params">(Stack_c s)</span></span>;</span><br><span class="line"><span class="comment">////栈的判空函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty_n</span><span class="params">(Stack_n s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty_c</span><span class="params">(Stack_c s)</span></span>;</span><br><span class="line"><span class="comment">//入栈函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_n</span><span class="params">(Stack_n *s,<span class="keyword">double</span> e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_c</span><span class="params">(Stack_c *s,<span class="keyword">char</span> e)</span></span>;</span><br><span class="line"><span class="comment">//出栈函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_n</span><span class="params">(Stack_n *s,<span class="keyword">double</span> *e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_c</span><span class="params">(Stack_c *s,<span class="keyword">char</span> *e)</span></span>;</span><br><span class="line"><span class="comment">//取栈顶函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetTop_n</span><span class="params">(Stack_n s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop_c</span><span class="params">(Stack_c s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2)</span></span>;<span class="comment">//判断优先级 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Operate</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">char</span> theta,<span class="keyword">double</span> b)</span></span>;<span class="comment">//二元运算 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">In</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">char</span> *OP)</span></span>;<span class="comment">//是否为 + - * / ( ) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;<span class="comment">//用于检查输入的多项式格式是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Poland</span><span class="params">(<span class="keyword">char</span> * s)</span></span>;<span class="comment">//主要功能实现函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> OP[<span class="number">7</span>]=&#123;<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>,<span class="string">'('</span>,<span class="string">')'</span>,<span class="string">'#'</span>&#125;; <span class="comment">//运算符数组(因多个函数使用故声明为公有的)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入表达式：\n"</span>);</span><br><span class="line">gets(s);</span><br><span class="line"><span class="keyword">double</span> r = Poland(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%1.2lf\n"</span>,r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_n</span><span class="params">(Stack_n *s)</span></span>&#123;</span><br><span class="line">s-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_c</span><span class="params">(Stack_c *s)</span></span>&#123;</span><br><span class="line">s-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈的判空函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty_n</span><span class="params">(Stack_n s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.top == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty_c</span><span class="params">(Stack_c s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.top == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_n</span><span class="params">(Stack_n *s,<span class="keyword">double</span> e)</span></span>&#123;</span><br><span class="line">s-&gt;top++;</span><br><span class="line">s-&gt;data[s-&gt;top] = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_c</span><span class="params">(Stack_c *s,<span class="keyword">char</span> e)</span></span>&#123;</span><br><span class="line">s-&gt;top++;</span><br><span class="line">s-&gt;data[s-&gt;top] = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_n</span><span class="params">(Stack_n *s,<span class="keyword">double</span> *e)</span></span>&#123;</span><br><span class="line">*e = s-&gt;data[s-&gt;top];</span><br><span class="line">s-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_c</span><span class="params">(Stack_c *s,<span class="keyword">char</span> *e)</span></span>&#123;</span><br><span class="line">*e = s-&gt;data[s-&gt;top];</span><br><span class="line">s-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取栈顶函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetTop_n</span><span class="params">(Stack_n s)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.data[s.top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop_c</span><span class="params">(Stack_c s)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.data[s.top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line"><span class="comment">//判定运算符的栈顶运算符与读入的运算符之间优先关系</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">switch</span>(c1)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">switch</span>(c2)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">    c=<span class="string">'&gt;'</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    c=<span class="string">'&lt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">if</span>(c2==<span class="string">'('</span>)&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="string">')'</span>)&#123;</span><br><span class="line">c=<span class="string">'='</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">    c=<span class="string">'&gt;'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="string">'#'</span>)&#123;</span><br><span class="line">c=<span class="string">'='</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Operate</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">char</span> theta,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="comment">//进行二元运算 a theta b</span></span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line">    <span class="keyword">switch</span>(theta)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">   sum=a+b;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">   sum=a-b;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">           sum=a*b;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">           sum=a/b;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">In</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">char</span> *OP)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断是不是运算符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">       <span class="keyword">if</span>(c==OP[i])   <span class="comment">//是运算符</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断思路：当前字符是运算符且前一位或后一位也是运算符且这3位都不为‘（’和‘）’时说明连续输入了两个运算符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *t = s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; i &lt; <span class="built_in">strlen</span>(s) - <span class="number">1</span> &amp;&amp; In(s[i],OP) &amp;&amp; (In(s[i - <span class="number">1</span>],OP) || In(s[i + <span class="number">1</span>],OP))</span><br><span class="line">&amp;&amp;(s[i] != <span class="string">'('</span> &amp;&amp; s[i] != <span class="string">')'</span>) &amp;&amp; (s[i - <span class="number">1</span>] != <span class="string">'('</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">')'</span>)</span><br><span class="line">&amp;&amp;(s[i + <span class="number">1</span>] != <span class="string">'('</span> &amp;&amp; s[i + <span class="number">1</span>] != <span class="string">')'</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入格式有误！！请检查是否存在连续输入了运算符等错误！！\n"</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Poland</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line"><span class="comment">//对多项式格式进行检查</span></span><br><span class="line">check(s);</span><br><span class="line">    <span class="comment">//进行多项式的求值以及后缀表达式的输出</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,len,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> a,b,sum;</span><br><span class="line">    <span class="keyword">char</span> c1=s[<span class="number">0</span>],e;</span><br><span class="line">    </span><br><span class="line">    Stack_c OPTR; <span class="comment">//运算符栈</span></span><br><span class="line">    Stack_n OPND; <span class="comment">//运算数栈</span></span><br><span class="line">    Init_c(&amp;OPTR);  <span class="comment">//初始化栈</span></span><br><span class="line">    Init_n(&amp;OPND);</span><br><span class="line">    </span><br><span class="line">    len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    s[len]=<span class="string">'#'</span>;</span><br><span class="line">    s[len+<span class="number">1</span>]=<span class="string">'\0'</span>;</span><br><span class="line">    Push_c(&amp;OPTR,<span class="string">'#'</span>);<span class="comment">//补‘#’作为结束标志</span></span><br><span class="line">    <span class="keyword">while</span>(s[i]!=<span class="string">'#'</span>||GetTop_c(OPTR)!=<span class="string">'#'</span>)&#123; <span class="comment">//遍历每一个字符 为‘#’结束循环</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(!In(s[i],OP))&#123; <span class="comment">//如果不是运算符</span></span><br><span class="line">        <span class="keyword">if</span>(c1==<span class="string">'.'</span>)&#123;<span class="comment">//如果上一个字符是小数点</span></span><br><span class="line">        flag++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    Pop_n(&amp;OPND,&amp;t);</span><br><span class="line">Push_n(&amp;OPND,t + (<span class="keyword">double</span>)(s[i] - <span class="string">'0'</span>) / <span class="built_in">pow</span>(<span class="number">10</span>,flag));<span class="comment">//对小数点后的部分 按位数运算并入栈 </span></span><br><span class="line">flag++;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=<span class="string">'.'</span>&amp;&amp;!flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!In(c1,OP)&amp;&amp;!IsEmpty_n(OPND))&#123;<span class="comment">//如果上一个字符是数字（说明是多位数） 根据位数运算后入栈</span></span><br><span class="line">            <span class="keyword">double</span> t;</span><br><span class="line">            Pop_n(&amp;OPND,&amp;t);</span><br><span class="line">                Push_n(&amp;OPND,t * <span class="number">10</span> + s[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则压入运算数栈</span></span><br><span class="line">            Push_n(&amp;OPND,(<span class="keyword">double</span>)(s[i]-<span class="string">'0'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    c1=s[i++]; <span class="comment">//读取下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//如果是运算符</span></span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span>(Precede(GetTop_c(OPTR),s[i]))&#123;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'&gt;'</span>:  <span class="comment">//当前运算符优先级低</span></span><br><span class="line">             Pop_c(&amp;OPTR,&amp;e); <span class="comment">//运算符出栈,和操作数的头两个数运算 </span></span><br><span class="line">             Pop_n(&amp;OPND,&amp;b);</span><br><span class="line">                     Pop_n(&amp;OPND,&amp;a);</span><br><span class="line">             Push_n(&amp;OPND,Operate(a,e,b)); <span class="comment">//计算结果入栈</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'='</span>: <span class="comment">//优先级相等</span></span><br><span class="line">             Pop_c(&amp;OPTR,&amp;e); <span class="comment">//弹出运算符栈顶元素</span></span><br><span class="line">             c1 = s[i++];</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">          Push_c(&amp;OPTR,s[i]); <span class="comment">//当前运算符优先级高 入栈</span></span><br><span class="line">            c1 = s[i++];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum=GetTop_n(OPND);</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">//返回运算数栈顶元素，即运算结果 </span></span><br><span class="line">&#125;<span class="comment">//@@ end @@</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="/images/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.png" alt="表达式求值">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong><em>代码也是看了很多博客帖子后总结出来的，建议好好利用搜索引擎。\</em></strong></p><p><strong><em>栈的实现、逆波兰转换和计算等基本概念很多书都有，我看的是学校教材，清华大学出版社出版、***</em></strong>严蔚敏老师的*<strong><em>**《数据结构（C语言版）》和程杰老师的《大话数据结构》。\</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;表达式求值是栈这种数据结构的一个很经典的应用，恰逢是数据结构期末实践题目，经过一定的努力终于也是实现了这个算法，所以分享下我的思路和经验，希望正准备尝试解决这个问题的同学可以少走些弯路，有所借鉴和收获。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人水平有限，文笔拙劣，有所意见和建议欢迎指出&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构 - 栈" scheme="https://qingshui3000.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>frist blog</title>
    <link href="https://qingshui3000.github.io/2019/12/16/frist-blog/"/>
    <id>https://qingshui3000.github.io/2019/12/16/frist-blog/</id>
    <published>2019-12-16T11:36:45.000Z</published>
    <updated>2019-12-16T11:57:12.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这里是我的技术博客，会记录一些学习过程中的体会和总结<br><a href="https://github.com/qingshui3000" target="_blank" rel="noopener">我的<code>github</code></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我的第一篇博客&quot;&gt;&lt;a href=&quot;#我的第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;我的第一篇博客&quot;&gt;&lt;/a&gt;我的第一篇博客&lt;/h2&gt;&lt;p&gt;这里是我的技术博客，会记录一些学习过程中的体会和总结&lt;br&gt;&lt;a href=&quot;https://git
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
