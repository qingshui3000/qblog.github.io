<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qssq的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qingshui3000.github.io/"/>
  <updated>2020-04-04T11:54:16.356Z</updated>
  <id>https://qingshui3000.github.io/</id>
  
  <author>
    <name>qssq</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>春招复习-MySQL总结</title>
    <link href="https://qingshui3000.github.io/2020/04/04/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0-MySQL%E6%80%BB%E7%BB%93/"/>
    <id>https://qingshui3000.github.io/2020/04/04/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0-MySQL%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-04T11:36:11.000Z</published>
    <updated>2020-04-04T11:54:16.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><h3 id="1-MySQL数据类型有哪些？"><a href="#1-MySQL数据类型有哪些？" class="headerlink" title="1.MySQL数据类型有哪些？"></a>1.MySQL数据类型有哪些？</h3><ol><li><p><strong>整数类型：</strong>包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节和8字节的整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p><p>整数类型可以指定长度，如<code>INT(11)</code>这样，但并不会限制其合法的数据范围，只会影响显示字符的个数。</p></li><li><p><strong>实数类型：</strong>包括FLOAT、DOUBLE、DECIMAL。<strong>DECIMAL</strong>可以存储比<strong>BIGINT</strong>还大的整数，能存储精确的小数；而<strong>FLOAT</strong>和<strong>DOUBLE</strong>是有取值范围的，并支持近似运算。计算是使用前两者效率更高。</p></li><li><p><strong>字符串类型：</strong>包括CHAR、VARCHAR、TEXT、BLOB。<strong>CHAR</strong>类型是定长的，在插入是会根据需求添加空格，适合存储很短的字符串，或者所有值都接近同一个长度，当CHAR存储的内容超出定义的长度时会截断；<strong>VARCHAR</strong>用于存储可变长度的字符串，比定长更节省空间，VARCHAR使用1或2个字节存储字符串长度，长度小于255时使用1字节，大于时是2字节，同样的，在内容长度超出设置的长度时会被截断。</p><p><em>使用策略：</em></p><ul><li>对于经常变更的数据，CHAR比VARCHAR更好，因为CHAR不易产生碎片。</li><li>对于很短的列，CHAR比VARCHAR的存储空间利用率更高。</li><li>使用时最好指定需要的长度，更长的列排序时更耗时间。</li><li>尽量避免TEXT/BLOB类型，查询时会使用临时表，导致很大的性能开销。</li></ul></li><li><p><strong>枚举类型(ENUM)：</strong>把不重复的数据存储为一个预定义的集合，在使用时可以代替常用的字符串。MySQL中的枚举类型实际存储的其实是整数。要避免使用数字作为枚举的常量。</p></li><li><p><strong>日期和时间类型:</strong>DATETIME、TIMESTAMP。推荐使用TIMESTAMP，空间效率更高。</p></li></ol><h3 id="2-数据库的三大范式是什么？"><a href="#2-数据库的三大范式是什么？" class="headerlink" title="2.数据库的三大范式是什么？"></a>2.数据库的三大范式是什么？</h3><ul><li><p><strong>第一范式：</strong>关系模式的基本要求，不满足第一范式不能称为关系型数据库，强调列的原子性，每个列不可以再拆分。</p></li><li><p><strong>第二范式：</strong>在第一范式的基础上，表必须有一个主键；非主键列完全依赖于主键，而不能依赖于主键的一部分。</p><p><strong>eg：</strong>订单表（order_id，product_id,price,quantity,product_name）,因为一个订单可以包含多种产品，所以主键应该是（order_id，product_id），但此时只有数量（quantity）完全依赖于主键，而商品名只依赖于主键的一部分（product_id），就不符合第二范式。</p><p><strong>不符合</strong>第二范式的设计容易产生冗余数据。</p></li><li><p><strong>第三范式：</strong>在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键形成转递依赖。</p><p><strong>eg：</strong>考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。</p><p>其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 <strong>CustomerID</strong>（非主键列），而不是直接依赖于主键，它是通过<strong>传递</strong>才依赖于<strong>主键</strong>，所以不符合 3NF。<br>通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。</p></li></ul><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><h3 id="1-MyISAM和InnoDB"><a href="#1-MyISAM和InnoDB" class="headerlink" title="1.MyISAM和InnoDB"></a>1.MyISAM和InnoDB</h3><p>MyISAM是MySQL 5.5之前的默认数据库引擎，5.5版本之后引入了新的默认数据库引擎。</p><p><strong>两者的对比：</strong></p><p>1.<strong>是否支持行级锁：</strong>MyISAM<strong>只有表级锁</strong>（table-level locking），而InnoDB<strong>支持行级锁</strong>（row-level locking）<strong>和表级锁</strong>，默认为<strong>行级锁</strong>。</p><p>2.<strong>是否支持事务和崩溃后的安全恢复</strong>：MyISAM着重强调的是性能，每次查询具有原子性，执行速度比InnoDB更快，但是不提供事务支持。InnoDB提供事务支持、外部键等高级数据库功能，具有事务提交（commit）、回滚（rollback）和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><p>3.<strong>是否支持外键</strong>：MyISAM不支持，InnoDB支持。</p><p>4.对于<strong>查询操作</strong>MyISAM更具有优势，因为其保存了行数。</p><p>5.InnoDB是为<strong>处理巨大数据量时的最大性能</strong>设计的存储引擎。</p><p>6.<strong>是否支持MVCC</strong>：仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更加高效；MVCC只在<code>READ COMMITED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作；MVCC可以使用乐观锁和悲观锁来实现，各数据库中MVCC实现并不统一。</p><p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p><p><strong>总结：</strong></p><p>最主要的区别就是MyISAM表支持FULLTEXT类型的全文索引、不支持事务、不支持行级锁、不支持外键。 InnoDB表支持事务、支持行级锁、支持外键。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="1-为什么使用索引（使用索引的好处）？"><a href="#1-为什么使用索引（使用索引的好处）？" class="headerlink" title="1.为什么使用索引（使用索引的好处）？"></a>1.为什么使用索引（使用索引的好处）？</h3><ul><li>优化查询速度，大大的减少了查询时检索的数据量。</li><li>帮助MySQL服务器避免排序和临时表（BTree索引是有序的，可以用于order by 和 group by操作）。</li><li>将磁盘从随机IO变为顺序IO（减少磁盘寻道时间）。</li></ul><h3 id="2-为什么索引可以提高查询速度？"><a href="#2-为什么索引可以提高查询速度？" class="headerlink" title="2.为什么索引可以提高查询速度？"></a>2.为什么索引可以提高查询速度？</h3><p>MySQL的基本存储结构是<strong>页</strong>，记录都存储在页里。</p><p><img src="http://q89f682iv.bkt.clouddn.com/blog/20200404/NICuXB9WKwov.jpg" alt="MySQL的基本存储结构是页"></p><p>​    <img src="http://q89f682iv.bkt.clouddn.com/blog/20200404/fmz0S9k9Uv7a.jpg" alt=""></p><ul><li><p><strong>每个数据页可以组成一个双向链表</strong></p></li><li><p><strong>每个数据页中的记录又可以组成一个单向链表</strong></p></li><li><p><strong>通过主键查找某条记录时会在页目录中使用二分法定位到对应的槽，然后遍历该槽对应分组中的记录链表找到对应的记录</strong></p></li><li><p>以其他列（非主键）作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</p></li></ul><p>所以，在不使用索引执行例如 <code>select * from user where username =&#39;xxx&#39;</code>这样没有任何优化的sql语句时，默认会执行下列步骤：</p><p>1.<strong>定位到记录所在的页（遍历双向链表）</strong></p><p>2.<strong>从所在页中查找对应记录（遍历单项链表）</strong></p><p>上述查询过程时间复杂度近似于<strong>O(logN)</strong></p><h4 id="使用索引的查询过程-以B-Tree索引为例"><a href="#使用索引的查询过程-以B-Tree索引为例" class="headerlink" title="使用索引的查询过程(以B+Tree索引为例)"></a>使用索引的查询过程(以B+Tree索引为例)</h4><p><img src="http://q89f682iv.bkt.clouddn.com/blog/20200404/AQu5t7MJrKIM.jpg?e=1586001739&token=PHVQrJJVdVeabMFYs6rqWpLrPUXNT5Qk_Y138u2m:qz3kXzRQcK-8_ln_B7yo95fYfE4=" alt="img"></p><p>要找id为8的记录时：</p><p><img src="http://q89f682iv.bkt.clouddn.com/blog/20200404/fASBasaM1aNq.jpg?e=1586001802&token=PHVQrJJVdVeabMFYs6rqWpLrPUXNT5Qk_Y138u2m:4tGPfKSaJKV3iMnqv_fYTEyrVv4=" alt="img"></p><h3 id="3-MySQL都有那些索引？"><a href="#3-MySQL都有那些索引？" class="headerlink" title="3.MySQL都有那些索引？"></a>3.MySQL都有那些索引？</h3><p>索引是在存储引擎层实现的，而非MySQL服务器层，所以<strong>不同的存储引擎具有不同的索引类型和实现。</strong></p><h4 id="1-BTree索引"><a href="#1-BTree索引" class="headerlink" title="1.BTree索引"></a>1.BTree索引</h4><p>大多数MySQL存储引擎默认的索引类型。</p><h4 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2.哈希索引"></a>2.哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。（即必须根据索引的全部列查询才能生效）；</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“<strong>自适应哈希索引</strong>”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 BTree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h4 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3.全文索引"></a>3.全文索引</h4><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h4 id="4-空间数据索引"><a href="#4-空间数据索引" class="headerlink" title="4.空间数据索引"></a>4.空间数据索引</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h3 id="补充：B树和B-树"><a href="#补充：B树和B-树" class="headerlink" title="补充：B树和B+树"></a>补充：B树和B+树</h3><ul><li>BTREE索引的底层数据结构是B树中的<strong>B+树</strong>，B树即平衡树(Balance Tree)，是一颗查找树，所有的叶子节点在同一层。</li><li>B+树基于B树，但B+树的叶子节点带有指向下一个叶子节点的指针，可以实现叶子节点的顺序查找。</li><li>B树索引的数据全部只在叶子节点中存储，查询更稳定。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><h4 id="关联-与红黑树的对比"><a href="#关联-与红黑树的对比" class="headerlink" title="关联-与红黑树的对比"></a>关联-与红黑树的对比</h4><p>理论上红黑树也可以用来实现索引，但文件系统和数据库系统普遍选用B+树作为索引的数据结构，主要有以下两个原因：</p><ul><li><p><strong>更少的查找次数</strong></p><p>红黑树的出度为2，B+树的出度通常很大，这意味着同样数据量下红黑树的高度会比B+树大很多，而根据平衡树的特性查找的时间复杂度与树高度有关，所以使用B+树可以得到比使用红黑树更小的查找次数。</p></li><li><p><strong>利用磁盘的预读取特性</strong></p><p>磁盘IO一次读取的数据量大小是固定的，B+树的出度大、数据都在叶子节点且叶子节点间有指针串联，所以使用B+树做索引可以减少磁盘的IO次数；而红黑树的出度为2，每个父节点仅有两个子节点，一次能读取的数据有限，无疑会大大增加磁盘IO次数，故只有在内存中使用红黑树这种数据结构。</p></li></ul><h3 id="4-什么是覆盖索引？优点有哪些？举个适用的场景（包括表结构和查询语句）。"><a href="#4-什么是覆盖索引？优点有哪些？举个适用的场景（包括表结构和查询语句）。" class="headerlink" title="4.什么是覆盖索引？优点有哪些？举个适用的场景（包括表结构和查询语句）。"></a>4.什么是覆盖索引？优点有哪些？举个适用的场景（包括表结构和查询语句）。</h3><p>覆盖索引：一个索引中包含所有需要查询字段的值（查询操作只需要访问索引，不需要访问数据行）。</p><p>优点：无需回表</p><p>1.索引条目通常远小于数据行大小，只需要读取索引，则mysql会极大地减少数据访问量。<br>2.因为索引是按照列值顺序存储的，所以对于IO密集的范围查找会比随机从磁盘读取每一行数据的IO少很多。<br>3.一些存储引擎如myisam在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用<br>4.innodb的聚簇索引，覆盖索引对innodb表特别有用</p><h3 id="5-索引的适用场景"><a href="#5-索引的适用场景" class="headerlink" title="5.索引的适用场景"></a>5.索引的适用场景</h3><ul><li>对于非常小的表，一般的全表扫描比建立索引效率更高。</li><li>对于中到大型表，索引就很有效。</li><li>对于特大型的表，建立和维护索引的代价将会随着增长，可使用一些技术直接区分出需要查询的一组数据、而不是一条一条的匹配，比如分区技术。</li></ul><h3 id="6-索引的优化和限制"><a href="#6-索引的优化和限制" class="headerlink" title="6.索引的优化和限制"></a>6.索引的优化和限制</h3><ol><li><p><strong>独立的列</strong></p><p>在进行查询时，索引列不能是表达式的一部分或函数的参数，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> age+<span class="number">1</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>这么写索引是不会生效的。</p></li><li><p><strong>多列索引</strong></p><p>在需要多个列来作为查询条件时，使用多列索引比使用多个单列索引效果更好。</p></li><li><p><strong>索引列的顺序</strong></p><p>让选择性最强的列放在前面，即区分度最强的列。</p></li><li><p><strong>最左前缀原则</strong></p><p>例如在user表中现有一联合索引（指多列组成的索引） （city，name）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city=<span class="string">'北京'</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'小明'</span>;//可以命中索引</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city=<span class="string">'北京'</span>;//可以命中索引</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小明'</span> <span class="keyword">and</span> age=<span class="number">10</span>;//都用上了但顺序不同，MySQL会自动优化，可以命中索引。</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小明'</span>；//不能命中索引</span><br></pre></td></tr></table></figure></li><li><p><strong>前缀索引</strong></p><p>对BLOB、TEXT、VARCHAR类型的列，必须使用前缀索引，只索引开始部分的字符。</p></li><li><p><strong>覆盖索引</strong></p><p>查询包含所需查询的所有字段的值，即数据都在索引里了，查询时只查询到索引就行了。</p><p>具有以下优点：</p><ul><li>索引一般小于数据化的大小，只读取索引能大大的减少数据访问量。</li><li>因为索引是按顺序存储的，检索索引就从随机IO变为顺序IO了，性能提升很大。</li><li>在一些存储引擎(例如MyISAM)中只会在内存中缓存索引，而数据则依赖操作系统来缓存，因此只检索索引可以免于系统调用的耗时。</li><li>对于InnoDB，若辅助索引（叶子节点储存了目标行数据的位置）可以覆盖索引，则无需访问主索引。</li></ul></li></ol><h3 id="7-使用索引时的注意事项"><a href="#7-使用索引时的注意事项" class="headerlink" title="7.使用索引时的注意事项"></a>7.使用索引时的注意事项</h3><ol><li>在经常需要搜索的列上，可以加快搜索的速度；</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li><li>在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li><li>在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；</li><li>避免 where 子句中对宇段施加函数，这会造成无法命中索引。</li><li>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</li><li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="1-请阐述数据库事务的几大特性，针对数据库事务，以mysql为例，该数据库有几种隔离级别，请阐述每种隔离级别所产生的效果。"><a href="#1-请阐述数据库事务的几大特性，针对数据库事务，以mysql为例，该数据库有几种隔离级别，请阐述每种隔离级别所产生的效果。" class="headerlink" title="1.请阐述数据库事务的几大特性，针对数据库事务，以mysql为例，该数据库有几种隔离级别，请阐述每种隔离级别所产生的效果。"></a>1.请阐述数据库事务的几大特性，针对数据库事务，以mysql为例，该数据库有几种隔离级别，请阐述每种隔离级别所产生的效果。</h3><h4 id="事务的四大特性-ACID-："><a href="#事务的四大特性-ACID-：" class="headerlink" title="事务的四大特性(ACID)："></a>事务的四大特性(ACID)：</h4><ol><li><strong>原子性：</strong>事务是不可分割的，要么全部执行，要么全部不执行。</li><li><strong>一致性：</strong>事务执行前后数据的完整性保持一致。</li><li><strong>隔离性：</strong>在事务正确提交前，其他事务不能访问该事务的数据。</li><li><strong>持久性</strong>：事务一旦提交，对数据库的改动是永久的。</li></ol><h4 id="MySQL数据库的隔离级别："><a href="#MySQL数据库的隔离级别：" class="headerlink" title="MySQL数据库的隔离级别："></a>MySQL数据库的隔离级别：</h4><p>SQL标准定义了4个隔离级别：</p><ul><li><strong>READ-UNCOMMITED（读取未提交）：</strong>最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能导致脏读、幻读、不可重复读。</strong></li><li><strong>READ-COMMITED（读取已提交）：</strong>允许读取并发事务已提交的数据变更，<strong>可以阻止脏读，但幻读和不可重复读仍可能发生。</strong></li><li><strong>REPEATABLE-READ（可重复读）：</strong>保证对同一字段的多次读取结果是一致的，<strong>可以阻止脏读、不可重复读，但幻读仍有可能发生。</strong></li><li><strong>SERIALIZABLE（不可重复读）：</strong> 最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次执行，<strong>可以阻止脏读、幻读、不可重复读</strong>，但执行速度比较慢，实现原理是<strong>完全锁定事务相关的数据库表。</strong></li></ul><h3 id="2-并发事务带来的问题"><a href="#2-并发事务带来的问题" class="headerlink" title="2.并发事务带来的问题"></a>2.并发事务带来的问题</h3><ul><li><strong>脏读：</strong>其他事务修改了该数据还未提交时提前读取了数据。</li><li><strong>不可重复读：</strong>在一个事务内多次读取同一数据，而在此期间有其他事务对该数据进行了修改，就造成该事务前后读取到的数据不一致。</li><li><strong>幻读：</strong>与不可重复读类似，在事务T1内读取了几行数据，而另一个事务T2插入了几条新的数据，那么T1就会发现多了几条原本不存在的数据，好像发生幻觉一样，成为幻读。</li><li><strong>丢失修改：</strong>指事务T1修改数据时，又一事务T2也进行了修改，就造成了事务T1的修改被丢失，例如A = 10，T1执行A-1，同时T2执行A-2，则最后A变成了8。</li></ul><h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;h2 id=&quot;MySQL基础&quot;&gt;&lt;a href=&quot;#MySQL基础&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="在复习MySQL中的一些总结" scheme="https://qingshui3000.github.io/categories/%E5%9C%A8%E5%A4%8D%E4%B9%A0MySQL%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="MySQL" scheme="https://qingshui3000.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程学习总结</title>
    <link href="https://qingshui3000.github.io/2020/01/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://qingshui3000.github.io/2020/01/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-05T08:45:27.000Z</published>
    <updated>2020-01-05T08:47:09.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程学习笔记"><a href="#Java多线程学习笔记" class="headerlink" title="Java多线程学习笔记"></a>Java多线程学习笔记</h1><h2 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h2><a id="more"></a><h3 id="1-最大化的利用硬件性能"><a href="#1-最大化的利用硬件性能" class="headerlink" title="1.最大化的利用硬件性能"></a>1.最大化的利用硬件性能</h3><p>多物理核心和线程的CPU早已大量普及，显然并发的执行任务能更好的发挥硬件性能；</p><h3 id="2-设计优势"><a href="#2-设计优势" class="headerlink" title="2.设计优势"></a>2.设计优势</h3><p><strong>示例场景：</strong>有两个任务需执行，任务一假定耗时10单位，任务二假定耗时1单位时间（实际中可能并不能在执行前确定任务耗时），如果不是多线程的环境下按顺序执行任务，则总耗时11，任务二虽然仅需要1单位时间执行，却要等待前面的任务一执行完后才被执行；而在多线程下执行时，因为cpu会在当前线程的时间片消耗完后切换至其他线程，所以虽然总耗时未变，但任务二无需等待任务一彻底执行完后再执行了。</p><p><strong>总结：多线程并不会提高程序的执行速度，因为上下文切换的原因，反而会降低速度。但如上述场景描述，可以减少用户的等待响应时间，提高了资源的利用效率和用户体验。</strong></p><h3 id="3-使用多线程带来的问题"><a href="#3-使用多线程带来的问题" class="headerlink" title="3.使用多线程带来的问题"></a>3.使用多线程带来的问题</h3><p>在并发编程时会出现数据的安全问题，线程与线程之间的竞争也会导致线程死锁和<em>锁死</em> 等<strong>活性故障</strong>，还有就是上文提到的上下文切换带来的额外开销。</p><p><a href=""https://blog.csdn.net/sinat_25991865/article/details/87949199"">关于线程锁死</a></p><h2 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h2><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">"继承Thread类创建线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread1 thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继承Thread类创建线程</span><br></pre></td></tr></table></figure><h3 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现Runnable接口创建线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable myThread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myThread2);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现Runnable接口创建线程</span><br></pre></td></tr></table></figure><p><strong>两种方法有何区别？</strong></p><p>两者实现的功能是一致的，继承Thread类创建线程在设计上有局限性，因为Java不支持多继承，在一些业务情景下方法1会无法继承Thread类，而通过将一实现了Runnable接口的类作为Thread的构造方法的参数可以在保留原有继承关系的情况下创建线程。因此，总体来说，实现Runnable接口的方法创建线程更好一些，1是Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；2是类可能只要求可执行就行，继承整个 Thread 类开销过大。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><strong>jdk1.8源码中对于Thread状态的枚举定义:</strong></p><h4 id="1-新建-NEW"><a href="#1-新建-NEW" class="headerlink" title="1.新建(NEW)"></a>1.新建(NEW)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br></pre></td></tr></table></figure><p>线程还未调用start()方法启动</p><h4 id="2-可运行-RUNNABLE"><a href="#2-可运行-RUNNABLE" class="headerlink" title="2.可运行(RUNNABLE)"></a>2.可运行(RUNNABLE)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment"> * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment"> * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment"> * such as processor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RUNNABLE,</span><br></pre></td></tr></table></figure><p>正在Java虚拟机中运行，但是在操作系统的层面有两种可能，一是处于运行状态，二是等待系统资源，资源调度完成后就开始运行，所以该状态指的是<strong>可被运行</strong>，具体有没有运行要结合操作系统资源调度的情况。</p><h4 id="3-阻塞-BLOCK"><a href="#3-阻塞-BLOCK" class="headerlink" title="3.阻塞(BLOCK)"></a>3.阻塞(BLOCK)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment"> * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment"> * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment"> * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BLOCKED,</span><br></pre></td></tr></table></figure><p>在线程准备进入synchronized同步块或者方法时需要请求获取一个监听器锁(monitor lock)，若此时其他线程已经占用了该监听器锁，则当前线程进入阻塞状态；在其他线程释放了该监听器锁后当前线程结束阻塞态。</p><h4 id="4-无限期等待-WAITING"><a href="#4-无限期等待-WAITING" class="headerlink" title="4.无限期等待(WAITING)"></a>4.无限期等待(WAITING)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment"> * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment"> * following methods:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment"> * perform a particular action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment"> * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WAITING,</span><br></pre></td></tr></table></figure><p>无期限的等待其他线程显式的唤醒。与阻塞态不同的是，阻塞是被动的，它在等待获取监听器锁，而等待是主动的，通过调用Object.wait()进入；</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h4 id="5-限期等待-TIMED-WAITING"><a href="#5-限期等待-TIMED-WAITING" class="headerlink" title="5.限期等待(TIMED_WAITING)"></a>5.限期等待(TIMED_WAITING)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment"> * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment"> * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TIMED_WAITING,</span><br></pre></td></tr></table></figure><p>与上一状态类似，但在一定时间后会被系统唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h4 id="6-死亡-TERMINATED"><a href="#6-死亡-TERMINATED" class="headerlink" title="6.死亡(TERMINATED)"></a>6.死亡(TERMINATED)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死亡态就是线程执行结束(run方法执行结束)或抛出异常而结束。</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>待更。。。</p><h2 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h2><h3 id="1-中断"><a href="#1-中断" class="headerlink" title="1.中断"></a>1.中断</h3><p><strong>interrupt()</strong></p><p><strong>interrupted()</strong></p><p><strong>isInterrupted()</strong></p><h3 id="2-sleep-和wait"><a href="#2-sleep-和wait" class="headerlink" title="2.sleep() 和wait()"></a>2.sleep() 和wait()</h3><ul><li><strong>sleep方法</strong>是Thread类的静态方法，作用是将当前线程顺便n毫秒，线程挂起进入阻塞态，时间到了后会解除阻塞进入可运行态，<strong>sleep方法不释放锁。</strong></li><li><strong>wait()方法</strong>是Object类的静态方法，只能在同步方法或同步块中使用，否则运行时会抛出IllegalMonitorStateException异常，调用后线程进入阻塞态，当调用notify或notifyAll方法后解除阻塞，等待<strong>重新获得互斥锁</strong>后进入可运行态，<strong>因为wait方法释放锁</strong></li></ul><h3 id="3-如何避免死锁"><a href="#3-如何避免死锁" class="headerlink" title="3.如何避免死锁"></a>3.如何避免死锁</h3><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>1.破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们使用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>2.破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>3.破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>4.破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><h3 id="4-多线程编程中的一些线程安全问题"><a href="#4-多线程编程中的一些线程安全问题" class="headerlink" title="4.多线程编程中的一些线程安全问题"></a>4.多线程编程中的一些线程安全问题</h3><h4 id="原子性、有序性和可见性-内存模型三大特性"><a href="#原子性、有序性和可见性-内存模型三大特性" class="headerlink" title="原子性、有序性和可见性(内存模型三大特性)"></a>原子性、有序性和可见性(内存模型三大特性)</h4><p>多线程环境下的线程安全主要体现在<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>方面。</p><p><strong>1.原子性</strong></p><p>Java内存模型为read、load、use、assign、store、write、lock和unlock操作保证了<strong>原子性</strong>；<strong>特殊的</strong>，对于long和double类型的数据，Java内存模型允许虚拟机将没有被volatile关键字修饰的64位变量的读、写操划分为两次对32位数据的操作进行，即在这种情况下，read、load、store、write操作可以不具有原子性。</p><p><strong>定义</strong></p><p>对于涉及到访问共享变量的操作，若当前操作是不可拆分的，即中间操作对于线程外部来说不可见，那么该操作就是原子操作1，该操作具有原子性。</p><p><strong>举例</strong></p><p>银行业务中的转账操作，A给B转账100元，基本步骤就是A账户减少100元，B账户就会多100元，虽然表面上可以拆分为这两步，但是我们不可能看到A账户少了100元、但B账户余额并未增加的情况。（现实中可能有延迟时间，这里忽略）</p><p><strong>如何保证原子性</strong></p><ul><li>利用<strong>互斥锁</strong>的排他性，保证同一时刻只有一个线程在操作共享变量。</li><li>利用CAS保证。</li></ul><p><strong>2.可见性</strong></p><p><strong>定义</strong></p><p>可见性是指一个线程对于共享变量的更新，对于后续访问该变量的线程是否可见的问题；Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">处理器缓存的概念</span><br><span class="line"></span><br><span class="line">现代处理器处理速度远大于主内存的处理速度，所以在主内存和处理器之间加入了寄存器，高速缓存，写缓冲器以及无效化队列等部件来加速内存的读写操作。也就是说，我们的处理器可以和这些部件进行读写操作的交互，这些部件可以称为处理器缓存。</span><br><span class="line"></span><br><span class="line">处理器对内存的读写操作，其实仅仅是与处理器缓存进行了交互。一个处理器的缓存上的内容无法被另外一个处理器读取，所以另外一个处理器必须通过缓存一致性协议来读取的其他处理器缓存中的数据，并且同步到自己的处理器缓存中，这样保证了其余处理器对该变量的更新对于另外处理器是可见的。</span><br></pre></td></tr></table></figure><p><strong>如何实现可见性</strong></p><ul><li>volatile关键字</li><li>synchronized，对一个变量执行unlock操作前，必须把变量值同步回主内存。</li><li>final关键字，被final关键字修饰的字段在构造器中一旦初始化完成，并且没有发生this逃逸（其他线程通过this引用到初始化一半的变量），那么其他线程就能看到该final字段的值。</li></ul><p><strong>3.有序性</strong></p><p><strong>定义：</strong>有序性是指一个处理器上运行的线程所执行的内存访问操作在另外一个处理器上运行的线程来看是否有序的问题。</p><p><strong>重排序：</strong><br>为了提高程序执行的性能，Java编译器在其认为不影响程序正确性的前提下，可能会对源代码顺序进行一定的调整，导致程序运行顺序与源代码顺序不一致。</p><p>重排序是对内存读写操作的一种优化，在单线程环境下不会导致程序的正确性问题，但是多线程环境下可能会影响程序的正确性。</p><p><strong>重排序举例：</strong><br><strong>Instance instance = new Instance()都发生了啥？</strong><br><strong>具体步骤如下所示三步：</strong></p><ul><li>在堆内存上分配对象的内存空间</li><li>在堆内存上初始化对象</li><li>设置instance指向刚分配的内存地址</li></ul><p>第二步和第三步可能会发生重排序，导致引用型变量指向了一个不为null但是也不完整的对象。（<strong>在多线程下的单例模式中，我们必须通过volatile来禁止指令重排序</strong>）</p><p><strong>总结：</strong></p><ul><li><strong>原子性</strong>是一组操作要么完全发生，要么没有发生，其余线程不会看到中间过程的存在。注意，<strong>原子操作+原子操作不一定还是原子操作。</strong></li><li><strong>可见性</strong>是指一个线程对共享变量的更新<strong>对于另外一个线程是否可见</strong>的问题。</li><li><strong>有序性</strong>是指一个线程对共享变量的更新在其余线程看起来是<strong>按照什么顺序执行</strong>的问题。</li><li>可以这么认为，<strong>原子性 + 可见性 -&gt; 有序性</strong></li></ul><h3 id="5-互斥同步"><a href="#5-互斥同步" class="headerlink" title="5.互斥同步"></a>5.互斥同步</h3><p>Java提供了两种锁机制来控制多个线程对于共享资源的互斥访问，一个是JVM实现的synchronized关键字，另一个是JDK实现的ReentrantLock</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul><li><strong>同步代码块</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只作用于同一个对象，如果分别调用两个对象上的同步代码块，就不会进行同步</strong></p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例1（同一个对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>示例2（两个对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li><strong>同步方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与同步块一样，作用于同一个对象</p><ul><li><strong>同步一个类</strong></li></ul><p>作用于整个类，也就是两个线程调用同一个类的不同对象的同步语句仍会进行同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><ul><li><strong>同步静态方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类</p><h4 id="ReentrantLock和synchronized的区别"><a href="#ReentrantLock和synchronized的区别" class="headerlink" title="ReentrantLock和synchronized的区别"></a>ReentrantLock和synchronized的区别</h4><p>ReentrantLock<strong>是显示锁</strong>，其提供了一些内部锁不具备的特性，但并不是内部锁的替代品。<strong>显式锁支持公平和非公平的调度方式</strong>，默认采用非公平调度。</p><p>synchronized 内部锁简单，但是不灵活。显示锁支持在一个方法内申请锁，并且在另一个方法里释放锁。<strong>显示锁定义了一个tryLock（）方法，尝试去获取锁</strong>，成功返回true，失败并不会导致其执行的线程被暂停而是直接返回false，即可以<strong>避免死锁</strong>。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><strong>1. 锁的实现</strong></p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="1-使用线程池的好处"><a href="#1-使用线程池的好处" class="headerlink" title="1.使用线程池的好处"></a>1.使用线程池的好处</h3><p>线程池和Http连接池、数据库连接池等类似，都是为了降低资源消耗、提高访问效率。</p><p><strong>使用线程池的好处：</strong></p><ul><li><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度。</strong>当任务到达时，任务可以<strong>不需要等待线程创建</strong>就能立即执行。</li><li><strong>提高线程的可管理性。</strong>线程是一种稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。</li></ul><h3 id="2-ThreadPoolExecutor"><a href="#2-ThreadPoolExecutor" class="headerlink" title="2.ThreadPoolExecutor"></a>2.ThreadPoolExecutor</h3><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><p>线程池实现类是Executor框架最核心的类</p><p><code>ThreadPoolExecutor</code>的3个重要参数：</p><ul><li><code>corePoolSize</code>：核心线程数，定义了最小可以同时运行的线程数量。</li><li><code>maximumPoolSize</code>：最大线程数。</li><li><code>workQueue</code>：存储线程的队列</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><h4 id="线程池的排队策略："><a href="#线程池的排队策略：" class="headerlink" title="线程池的排队策略："></a>线程池的排队策略：</h4><ul><li>如果正在运行的线程数小于核心线程数，则Executor始终首选添加新的线程进入线程池，而不排队。</li><li>如果正在运行的线程等于或多余核心线程数，则Executor始终首选将新请求加入队列进行排队。</li><li>如果无法将请求加入队列，即队列已满，则创建新的线程，若创建此线程后超出<code>maximumPoolSize</code>，则任务将会拒绝。</li></ul><h4 id="常见的线程池类型"><a href="#常见的线程池类型" class="headerlink" title="常见的线程池类型"></a>常见的线程池类型</h4><p><strong>newCachedThreadPool()</strong></p><ul><li>核心线程池大小为0，最大线程数不受限，即每次请求都会创建一个线程。</li><li>适合用于执行大量耗时短且提交频率高的任务场景。</li></ul><p><strong>newFixedThreadPool()</strong></p><ul><li>固定大小的线程池</li><li>当线程池大小达到核心线程数时，会将新任务加入<code>LinkedBlockingQueue</code>。</li><li>线程池中的线程执行完手头的任务后，会在循环中反复从<code>LinkedBlockingQueue</code>中获取任务执行。</li></ul><p><code>LinkedBlockingQueue</code>是一个无界队列（容量为Integer.MAX_VALUE）。</p><p>为什么不推荐使用<code>FixedThreadPool</code>：</p><p>1.线程池达到核心线程数后不会继续增加。</p><p>2.由于无界队列的存在，<code>maximumPoolSize</code>将会是一个无效参数，即不可能存在任务队列满的情况（<code>FixedThreadPool</code>中的<code>maximumPoolSize</code>和<code>corePoolSize</code>被设置为同一个值）。</p><p>3.同理，由于1,2，<code>keepAliveTime</code>也将会是一个无效参数。</p><p>4.由于无界队列的存在，运行中的<code>FixedThreadPoll</code>不会拒绝任务，在任务比较多的时候会导致OOM（内存溢出）。</p><p><strong>newSingleThreadExecutor()</strong></p><p>便于实现生产者-消费者模式</p><h4 id="常见的阻塞队列"><a href="#常见的阻塞队列" class="headerlink" title="常见的阻塞队列"></a>常见的阻塞队列</h4><p><strong>ArrayBlockingQueue:</strong></p><ul><li>内部使用一个<strong>数组</strong>作为其存储空间，数组的存储空间是<strong>预先分配</strong>的</li><li><strong>优点是</strong> put 和 take操作不会增加GC的负担（因为空间是预先分配的）</li><li><strong>缺点是</strong> put 和 take操作使用同一个锁，可能导致锁争用，导致较多的上下文切换。</li><li>ArrayBlockingQueue适合在生产者线程和消费者线程之间的<strong>并发程序较低</strong>的情况下使用。</li></ul><p><strong>LinkedBlockingQueue：</strong></p><ul><li>是一个无界队列（其实队列长度是Integer.MAX_VALUE）</li><li>内部存储空间是一个<strong>链表</strong>，并且链表节点所需的<strong>存储空间是动态分配</strong>的</li><li><strong>优点是</strong> put 和 take 操作使用两个显式锁（putLock和takeLock）</li><li><strong>缺点是</strong>增加了GC的负担，因为空间是动态分配的。</li><li>LinkedBlockingQueue适合在生产者线程和消费者线程之间的并发程序较高的情况下使用。</li></ul><p><strong>SynchronousQueue：</strong><br>SynchronousQueue可以被看做一种特殊的有界队列。生产者线程生产一个产品之后，会等待消费者线程来取走这个产品，才会接着生产下一个产品，适合在生产者线程和消费者线程之间的处理能力相差不大的情况下使用。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每个线程都可以拥有独立的副本，不会影响到其他线程的变量副本。</p><p>ThreadLocal类用于实现<strong>线程的本地存储</strong></p><h3 id="2-ThreadLocal内部实现机制"><a href="#2-ThreadLocal内部实现机制" class="headerlink" title="2.ThreadLocal内部实现机制"></a>2.ThreadLocal内部实现机制</h3><ul><li>每个线程内部都会维护一个类似HashMap的对象，称为<strong>ThreadLocalMap</strong>，里面会包含若干<strong>Entry(KEY-VALUE键值对)</strong>，相应的线程被称为这些Entry的属主线程。</li><li><strong>Entry的KEY是一个ThreadLocal实例，VALUE是一个线程持有对象。</strong>Entry的作用即为其属主线程建立起一个ThreadLocal实例和线程持有对象的对应关系。</li><li>Entry对KEY是弱引用，对VALUE是强引用（GC时的区别）。</li></ul><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>java.util.concurrent.atomic包下的AtomicInteger等原子类用于保证复合操作的原子性。</p><ul><li><strong>AtomicInteger类提供了getAndIncrement和incrementAndGet等原子性的自增自减等操作</strong>。</li><li><strong>Atomic等原子类内部使用了CAS来保证原子性。</strong></li></ul><h2 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h2><p>代更。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java多线程学习笔记&quot;&gt;&lt;a href=&quot;#Java多线程学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Java多线程学习笔记&quot;&gt;&lt;/a&gt;Java多线程学习笔记&lt;/h1&gt;&lt;h2 id=&quot;为什么要使用多线程&quot;&gt;&lt;a href=&quot;#为什么要使用多线程&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用多线程&quot;&gt;&lt;/a&gt;为什么要使用多线程&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://qingshui3000.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer NO.7 重建二叉树</title>
    <link href="https://qingshui3000.github.io/2019/12/28/%E5%89%91%E6%8C%87offer%20NO.7%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://qingshui3000.github.io/2019/12/28/%E5%89%91%E6%8C%87offer%20NO.7%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2019-12-28T12:30:02.000Z</published>
    <updated>2020-04-04T11:37:40.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><a id="more"></a><p><a href=""https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"">牛客网-重建二叉树</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据二叉数的前序和中序遍历构建二叉树，二叉树的前序遍历和中序遍历结果，以int数组的形式输入</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据树的前序和中序遍历规律，前序遍历的第一个结点是二叉树的根节点，在中序遍历中以根节点划分，左边就是二叉树的左子树，右边是右子树，按这个规律进行递归，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; in.length;i++)&#123;</span><br><span class="line">            map.put(in[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> construct(pre,<span class="number">0</span>,pre.length - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">construct</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> inl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[l]);</span><br><span class="line">        <span class="keyword">int</span> index = map.get(root.val);</span><br><span class="line">        <span class="keyword">int</span> lsize = index - inl;</span><br><span class="line">        root.left = construct(pre,l + <span class="number">1</span>,l + lsize,inl);</span><br><span class="line">        root.right = construct(pre,l + lsize + <span class="number">1</span>,r,inl + lsize + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;重建二叉树&quot;&gt;&lt;a href=&quot;#重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;重建二叉树&quot;&gt;&lt;/a&gt;重建二叉树&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>表达式求值</title>
    <link href="https://qingshui3000.github.io/2019/12/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <id>https://qingshui3000.github.io/2019/12/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</id>
    <published>2019-12-20T12:27:59.000Z</published>
    <updated>2019-12-20T12:52:43.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>表达式求值是栈这种数据结构的一个很经典的应用，恰逢是数据结构期末实践题目，经过一定的努力终于也是实现了这个算法，所以分享下我的思路和经验，希望正准备尝试解决这个问题的同学可以少走些弯路，有所借鉴和收获。</p><p><strong>个人水平有限，文笔拙劣，有所意见和建议欢迎指出</strong></p><a id="more"></a><p>我们日常使用的四则运算式如 1+1 被称为中缀表达式，即所有的运算符号都在运算数的中间出现，我们在初学编程时都练习过简单的二元运算，但当求值问题扩大到一个完整的四则运算式的时候，就需要考虑<strong>运算符优先级、括号</strong>等多个问题，解决了这些问题也就实现了表达式求值。</p><p>表达式求值问题常用的也是最广泛的解决方法是逆波兰式转换法，主要步骤可简单分为两步，用户输入的中缀表达式转化为后缀表达式（逆波兰式），再对逆波兰式进行运算。但在编程过程中我发现简单的分为两步是行不通的，因为涉及到多位数和浮点数，由于输入时统一存储为字符串，在进行中缀到后缀的转换后无法得到正确的后缀式字符串，由于c语言中char型数据实际上也是int型数据，这就进一步增加了正确转换的难度，从而也就无法在逆波兰式的计算中得出正确的结果，所以在编程实现时将这两步合为一个函数实现，<strong>即以字符串形式存储键盘输入的表达式后，对该字符串逐位处理，通过ASCII码值的判断分为数字或小数点、运算符两种情况，然后按照判断结果执行相应的语句。</strong></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>创建<strong>一char型数组</strong>用于存储输入的中缀表达式，在中缀表达式向后缀表达式的转化以及后缀表达式的计算中（<strong>详情见各种数据结构教材或书籍，或相关博客，实现此算法必须要实现了解这些过程</strong>）我们知道，因为涉及到运算符优先级的判断和后缀表达式的计算的部分我们需要借助栈来实现，所以需要创建<strong>一double型栈和一char型栈</strong>，分别用于存储操作数和运算符，栈的存储可随意选用线性结构或链式结构，需要实现以下操作函数：</p><ul><li>初始化</li><li>出栈</li><li>入栈</li><li>取栈顶</li><li>判空</li></ul><p>接下来对如何处理输入的表达式做详细介绍</p><h3 id="1-数字或小数点（非运算符）"><a href="#1-数字或小数点（非运算符）" class="headerlink" title="1.数字或小数点（非运算符）"></a>1.数字或小数点（非运算符）</h3><p><img src="/images/ascii.png" alt="ascii">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上图为ASCII码对照表</p><p>通过ASCII码我们可以得出输入的是数字（0-9）的条件，但因为存在多位数的情况，所以当前数字可能是输入的操作数的十位或百位等，所以不能简单的压入数字栈就完事，我的解决方法是每当遇到数字位都进行一次判断，检查表达式字符串中它的前一位是否为数字，若是，则说明这是个多位数，则将前一位（已入栈）出栈与10的n次幂做乘积后与当前位求和再入栈；对于例如12.34这类浮点数，则在判断当前位不是运算符后首先检查是否为小数点，若是则说明直到下一个运算符都是该浮点数的小数位，则与求多位整数（例12.34的整数位）值类似，与10的负n次幂做乘积累加求和知道遇到下一个运算符时入栈。</p><p><img src="/images/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%AD%90%E5%9B%BE2.png" alt="表达式求值子图2">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上图是我做的流程图（第一次做，略丑，希望能帮助理解即可）</p><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><p>运算符的处理相对于操作数就简单许多了，唯一的小问题就是运算符优先级的判断，我第一次写的时候写了层层嵌套的if和switch语句，做了简化修改后可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line"><span class="comment">//判定运算符的栈顶运算符与读入的运算符之间优先关系</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">switch</span>(c1)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">switch</span>(c2)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">    c=<span class="string">'&gt;'</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    c=<span class="string">'&lt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">if</span>(c2==<span class="string">'('</span>)&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="string">')'</span>)&#123;</span><br><span class="line">c=<span class="string">'='</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">    c=<span class="string">'&gt;'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="string">'#'</span>)&#123;</span><br><span class="line">c=<span class="string">'='</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>解决了优先级的判断问题后，根据中缀转后缀的步骤，优先级高于栈顶入栈，低的出栈运算直到栈顶元素优先级低于当前位，思路如下：<img src="/images/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%AD%90%E5%9B%BE3.png" alt="表达式求值子图3">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如上所述，对表达式字符串处理完毕后，此时运算结果其实就是操作数栈的栈顶元素，且操作数栈仅剩该数字，输出即可。</p><p>下面是完整代码和流程图，如果文字描述不足以让你彻底明白这个问题的解决方法，希望能静下心多看看代码，愿你能保持学习的热情</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zhao6582@qq.com 12/18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="comment">//double栈，用于存放运算数 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;Stack_n;</span><br><span class="line"><span class="comment">//char栈，用于存放运算符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;Stack_c;</span><br><span class="line"><span class="comment">//栈的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_n</span><span class="params">(Stack_n s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_c</span><span class="params">(Stack_c s)</span></span>;</span><br><span class="line"><span class="comment">////栈的判空函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty_n</span><span class="params">(Stack_n s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty_c</span><span class="params">(Stack_c s)</span></span>;</span><br><span class="line"><span class="comment">//入栈函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_n</span><span class="params">(Stack_n *s,<span class="keyword">double</span> e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_c</span><span class="params">(Stack_c *s,<span class="keyword">char</span> e)</span></span>;</span><br><span class="line"><span class="comment">//出栈函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_n</span><span class="params">(Stack_n *s,<span class="keyword">double</span> *e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_c</span><span class="params">(Stack_c *s,<span class="keyword">char</span> *e)</span></span>;</span><br><span class="line"><span class="comment">//取栈顶函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetTop_n</span><span class="params">(Stack_n s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop_c</span><span class="params">(Stack_c s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2)</span></span>;<span class="comment">//判断优先级 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Operate</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">char</span> theta,<span class="keyword">double</span> b)</span></span>;<span class="comment">//二元运算 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">In</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">char</span> *OP)</span></span>;<span class="comment">//是否为 + - * / ( ) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;<span class="comment">//用于检查输入的多项式格式是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Poland</span><span class="params">(<span class="keyword">char</span> * s)</span></span>;<span class="comment">//主要功能实现函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> OP[<span class="number">7</span>]=&#123;<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>,<span class="string">'('</span>,<span class="string">')'</span>,<span class="string">'#'</span>&#125;; <span class="comment">//运算符数组(因多个函数使用故声明为公有的)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入表达式：\n"</span>);</span><br><span class="line">gets(s);</span><br><span class="line"><span class="keyword">double</span> r = Poland(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%1.2lf\n"</span>,r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_n</span><span class="params">(Stack_n *s)</span></span>&#123;</span><br><span class="line">s-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_c</span><span class="params">(Stack_c *s)</span></span>&#123;</span><br><span class="line">s-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈的判空函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty_n</span><span class="params">(Stack_n s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.top == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty_c</span><span class="params">(Stack_c s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.top == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_n</span><span class="params">(Stack_n *s,<span class="keyword">double</span> e)</span></span>&#123;</span><br><span class="line">s-&gt;top++;</span><br><span class="line">s-&gt;data[s-&gt;top] = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_c</span><span class="params">(Stack_c *s,<span class="keyword">char</span> e)</span></span>&#123;</span><br><span class="line">s-&gt;top++;</span><br><span class="line">s-&gt;data[s-&gt;top] = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_n</span><span class="params">(Stack_n *s,<span class="keyword">double</span> *e)</span></span>&#123;</span><br><span class="line">*e = s-&gt;data[s-&gt;top];</span><br><span class="line">s-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_c</span><span class="params">(Stack_c *s,<span class="keyword">char</span> *e)</span></span>&#123;</span><br><span class="line">*e = s-&gt;data[s-&gt;top];</span><br><span class="line">s-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取栈顶函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetTop_n</span><span class="params">(Stack_n s)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.data[s.top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop_c</span><span class="params">(Stack_c s)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.data[s.top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Precede</span><span class="params">(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line"><span class="comment">//判定运算符的栈顶运算符与读入的运算符之间优先关系</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">switch</span>(c1)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">switch</span>(c2)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">    c=<span class="string">'&gt;'</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    c=<span class="string">'&lt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">if</span>(c2==<span class="string">'('</span>)&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="string">')'</span>)&#123;</span><br><span class="line">c=<span class="string">'='</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">    c=<span class="string">'&gt;'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="string">'#'</span>)&#123;</span><br><span class="line">c=<span class="string">'='</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">c=<span class="string">'&lt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Operate</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">char</span> theta,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="comment">//进行二元运算 a theta b</span></span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line">    <span class="keyword">switch</span>(theta)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">   sum=a+b;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">   sum=a-b;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">           sum=a*b;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">           sum=a/b;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">In</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">char</span> *OP)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断是不是运算符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">       <span class="keyword">if</span>(c==OP[i])   <span class="comment">//是运算符</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断思路：当前字符是运算符且前一位或后一位也是运算符且这3位都不为‘（’和‘）’时说明连续输入了两个运算符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *t = s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; i &lt; <span class="built_in">strlen</span>(s) - <span class="number">1</span> &amp;&amp; In(s[i],OP) &amp;&amp; (In(s[i - <span class="number">1</span>],OP) || In(s[i + <span class="number">1</span>],OP))</span><br><span class="line">&amp;&amp;(s[i] != <span class="string">'('</span> &amp;&amp; s[i] != <span class="string">')'</span>) &amp;&amp; (s[i - <span class="number">1</span>] != <span class="string">'('</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">')'</span>)</span><br><span class="line">&amp;&amp;(s[i + <span class="number">1</span>] != <span class="string">'('</span> &amp;&amp; s[i + <span class="number">1</span>] != <span class="string">')'</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入格式有误！！请检查是否存在连续输入了运算符等错误！！\n"</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Poland</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line"><span class="comment">//对多项式格式进行检查</span></span><br><span class="line">check(s);</span><br><span class="line">    <span class="comment">//进行多项式的求值以及后缀表达式的输出</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,len,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> a,b,sum;</span><br><span class="line">    <span class="keyword">char</span> c1=s[<span class="number">0</span>],e;</span><br><span class="line">    </span><br><span class="line">    Stack_c OPTR; <span class="comment">//运算符栈</span></span><br><span class="line">    Stack_n OPND; <span class="comment">//运算数栈</span></span><br><span class="line">    Init_c(&amp;OPTR);  <span class="comment">//初始化栈</span></span><br><span class="line">    Init_n(&amp;OPND);</span><br><span class="line">    </span><br><span class="line">    len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    s[len]=<span class="string">'#'</span>;</span><br><span class="line">    s[len+<span class="number">1</span>]=<span class="string">'\0'</span>;</span><br><span class="line">    Push_c(&amp;OPTR,<span class="string">'#'</span>);<span class="comment">//补‘#’作为结束标志</span></span><br><span class="line">    <span class="keyword">while</span>(s[i]!=<span class="string">'#'</span>||GetTop_c(OPTR)!=<span class="string">'#'</span>)&#123; <span class="comment">//遍历每一个字符 为‘#’结束循环</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(!In(s[i],OP))&#123; <span class="comment">//如果不是运算符</span></span><br><span class="line">        <span class="keyword">if</span>(c1==<span class="string">'.'</span>)&#123;<span class="comment">//如果上一个字符是小数点</span></span><br><span class="line">        flag++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    Pop_n(&amp;OPND,&amp;t);</span><br><span class="line">Push_n(&amp;OPND,t + (<span class="keyword">double</span>)(s[i] - <span class="string">'0'</span>) / <span class="built_in">pow</span>(<span class="number">10</span>,flag));<span class="comment">//对小数点后的部分 按位数运算并入栈 </span></span><br><span class="line">flag++;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=<span class="string">'.'</span>&amp;&amp;!flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!In(c1,OP)&amp;&amp;!IsEmpty_n(OPND))&#123;<span class="comment">//如果上一个字符是数字（说明是多位数） 根据位数运算后入栈</span></span><br><span class="line">            <span class="keyword">double</span> t;</span><br><span class="line">            Pop_n(&amp;OPND,&amp;t);</span><br><span class="line">                Push_n(&amp;OPND,t * <span class="number">10</span> + s[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则压入运算数栈</span></span><br><span class="line">            Push_n(&amp;OPND,(<span class="keyword">double</span>)(s[i]-<span class="string">'0'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    c1=s[i++]; <span class="comment">//读取下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//如果是运算符</span></span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span>(Precede(GetTop_c(OPTR),s[i]))&#123;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'&gt;'</span>:  <span class="comment">//当前运算符优先级低</span></span><br><span class="line">             Pop_c(&amp;OPTR,&amp;e); <span class="comment">//运算符出栈,和操作数的头两个数运算 </span></span><br><span class="line">             Pop_n(&amp;OPND,&amp;b);</span><br><span class="line">                     Pop_n(&amp;OPND,&amp;a);</span><br><span class="line">             Push_n(&amp;OPND,Operate(a,e,b)); <span class="comment">//计算结果入栈</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'='</span>: <span class="comment">//优先级相等</span></span><br><span class="line">             Pop_c(&amp;OPTR,&amp;e); <span class="comment">//弹出运算符栈顶元素</span></span><br><span class="line">             c1 = s[i++];</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">          Push_c(&amp;OPTR,s[i]); <span class="comment">//当前运算符优先级高 入栈</span></span><br><span class="line">            c1 = s[i++];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum=GetTop_n(OPND);</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">//返回运算数栈顶元素，即运算结果 </span></span><br><span class="line">&#125;<span class="comment">//@@ end @@</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="/images/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.png" alt="表达式求值">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong><em>代码也是看了很多博客帖子后总结出来的，建议好好利用搜索引擎。\</em></strong></p><p><strong><em>栈的实现、逆波兰转换和计算等基本概念很多书都有，我看的是学校教材，清华大学出版社出版、***</em></strong>严蔚敏老师的*<strong><em>**《数据结构（C语言版）》和程杰老师的《大话数据结构》。\</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;表达式求值是栈这种数据结构的一个很经典的应用，恰逢是数据结构期末实践题目，经过一定的努力终于也是实现了这个算法，所以分享下我的思路和经验，希望正准备尝试解决这个问题的同学可以少走些弯路，有所借鉴和收获。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人水平有限，文笔拙劣，有所意见和建议欢迎指出&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构 - 栈" scheme="https://qingshui3000.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列的转换</title>
    <link href="https://qingshui3000.github.io/2019/12/17/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://qingshui3000.github.io/2019/12/17/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2019-12-17T15:49:25.000Z</published>
    <updated>2020-04-04T11:49:33.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用栈实现队列-amp-用队列实现栈问题"><a href="#用栈实现队列-amp-用队列实现栈问题" class="headerlink" title="用栈实现队列&amp;用队列实现栈问题"></a>用栈实现队列&amp;用队列实现栈问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈和队列是两种常见的数据结构，简单概括就是栈是“先入后出”的读写规则，队列则遵循“先入先出”的顺序，在理解这些的基础上对于如何使用A实现B的问题就很容易实现了。</p><a id="more"></a><h2 id="一-栈实现队列"><a href="#一-栈实现队列" class="headerlink" title="一.栈实现队列"></a>一.栈实现队列</h2><h3 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1.思路分析"></a>1.思路分析</h3><p>首先，队列的基本操作有入队操作<code>add</code>、出队操作<code>pool</code>和取队首操作<code>peek</code>，而按照队列的“先入先出”的规律，我们可以新建一个数据栈data和一个辅助栈help来实现这些操作，<code>add</code>时将数据压入data栈即可，例如依次<code>add</code>1、2、3、4、5，这时data栈存储情况如下图<img src="/images/stacktoqueue1.png" alt="stacktoqueue1"></p><p>假如此时执行<code>pool</code>操作，按栈的读取规则得到的是最后入栈、处于栈顶的5，显然是不正确的(应当是最先输入的1)，那么如何得到正确的读取序列呢？其实很简单，还记得刚刚提过的辅助栈吗，我们将data栈内的数据依次弹出直到data栈弹空<img src="/images/stacktoqueue2.png" alt="stacktoqueue2"></p><p>这时我们发现，只要对help栈执行出栈操作，即可按正确的顺序输出了。</p><h3 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2.完整代码"></a>2.完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackToQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackToQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> newNum)</span></span>&#123;</span><br><span class="line">        data.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(help.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!data.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> t = data.pop();</span><br><span class="line">                help.push(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(help.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!data.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> t = data.pop();</span><br><span class="line">                help.push(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackToQueue queue = <span class="keyword">new</span> StackToQueue();</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        queue.add(<span class="number">4</span>);</span><br><span class="line">        queue.add(<span class="number">5</span>);</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-队列实现栈"><a href="#二-队列实现栈" class="headerlink" title="二.队列实现栈"></a>二.队列实现栈</h2><h3 id="1-思路分析-1"><a href="#1-思路分析-1" class="headerlink" title="1.思路分析"></a>1.思路分析</h3><p>首先明确队列和栈的基本操作，如何使用“先入先出”的队列来实现“先入后出”的栈呢？答案与问题一类似，使用两个队列即可。</p><h3 id="2-完整代码-1"><a href="#2-完整代码-1" class="headerlink" title="2.完整代码"></a>2.完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueToStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueToStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span></span>&#123;</span><br><span class="line">        data.add(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (data.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            help.add(data.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = data.poll();</span><br><span class="line">        swap();</span><br><span class="line">        data.add(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (data.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            help.add(data.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = data.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; t = data;</span><br><span class="line">        data = help;</span><br><span class="line">        help = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        QueueToStack stack = <span class="keyword">new</span> QueueToStack();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">        stack.push(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-关联问题–栈的getMin-操作"><a href="#三-关联问题–栈的getMin-操作" class="headerlink" title="三.关联问题–栈的getMin()操作"></a>三.关联问题–栈的getMin()操作</h2><p>待更</p><h3 id="1-思路分析-2"><a href="#1-思路分析-2" class="headerlink" title="1.思路分析"></a>1.思路分析</h3><h3 id="2-完整代码-2"><a href="#2-完整代码-2" class="headerlink" title="2.完整代码"></a>2.完整代码</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用栈实现队列-amp-用队列实现栈问题&quot;&gt;&lt;a href=&quot;#用栈实现队列-amp-用队列实现栈问题&quot; class=&quot;headerlink&quot; title=&quot;用栈实现队列&amp;amp;用队列实现栈问题&quot;&gt;&lt;/a&gt;用栈实现队列&amp;amp;用队列实现栈问题&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;栈和队列是两种常见的数据结构，简单概括就是栈是“先入后出”的读写规则，队列则遵循“先入先出”的顺序，在理解这些的基础上对于如何使用A实现B的问题就很容易实现了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构 - 栈 - 队列" scheme="https://qingshui3000.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>frist blog</title>
    <link href="https://qingshui3000.github.io/2019/12/16/frist-blog/"/>
    <id>https://qingshui3000.github.io/2019/12/16/frist-blog/</id>
    <published>2019-12-16T11:36:45.000Z</published>
    <updated>2019-12-16T11:57:12.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这里是我的技术博客，会记录一些学习过程中的体会和总结<br><a href="https://github.com/qingshui3000" target="_blank" rel="noopener">我的<code>github</code></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我的第一篇博客&quot;&gt;&lt;a href=&quot;#我的第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;我的第一篇博客&quot;&gt;&lt;/a&gt;我的第一篇博客&lt;/h2&gt;&lt;p&gt;这里是我的技术博客，会记录一些学习过程中的体会和总结&lt;br&gt;&lt;a href=&quot;https://git
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
