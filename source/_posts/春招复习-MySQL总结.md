---
title: 春招复习-MySQL总结
permalink: 春招复习-MySQL总结
date: 2020-04-04 19:36:11
tags: 'MySQL'
categories: 在复习MySQL中的一些总结
---
# MySQL

## MySQL基础

<!--more-->

### 1.MySQL数据类型有哪些？

1. **整数类型：**包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节和8字节的整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。

   整数类型可以指定长度，如`INT(11)`这样，但并不会限制其合法的数据范围，只会影响显示字符的个数。

2. **实数类型：**包括FLOAT、DOUBLE、DECIMAL。**DECIMAL**可以存储比**BIGINT**还大的整数，能存储精确的小数；而**FLOAT**和**DOUBLE**是有取值范围的，并支持近似运算。计算是使用前两者效率更高。

3. **字符串类型：**包括CHAR、VARCHAR、TEXT、BLOB。**CHAR**类型是定长的，在插入是会根据需求添加空格，适合存储很短的字符串，或者所有值都接近同一个长度，当CHAR存储的内容超出定义的长度时会截断；**VARCHAR**用于存储可变长度的字符串，比定长更节省空间，VARCHAR使用1或2个字节存储字符串长度，长度小于255时使用1字节，大于时是2字节，同样的，在内容长度超出设置的长度时会被截断。

   *使用策略：*

   * 对于经常变更的数据，CHAR比VARCHAR更好，因为CHAR不易产生碎片。
   * 对于很短的列，CHAR比VARCHAR的存储空间利用率更高。
   * 使用时最好指定需要的长度，更长的列排序时更耗时间。
   * 尽量避免TEXT/BLOB类型，查询时会使用临时表，导致很大的性能开销。

4. **枚举类型(ENUM)：**把不重复的数据存储为一个预定义的集合，在使用时可以代替常用的字符串。MySQL中的枚举类型实际存储的其实是整数。要避免使用数字作为枚举的常量。

5. **日期和时间类型:**DATETIME、TIMESTAMP。推荐使用TIMESTAMP，空间效率更高。

### 2.数据库的三大范式是什么？

* **第一范式：**关系模式的基本要求，不满足第一范式不能称为关系型数据库，强调列的原子性，每个列不可以再拆分。

* **第二范式：**在第一范式的基础上，表必须有一个主键；非主键列完全依赖于主键，而不能依赖于主键的一部分。

  **eg：**订单表（order_id，product_id,price,quantity,product_name）,因为一个订单可以包含多种产品，所以主键应该是（order_id，product_id），但此时只有数量（quantity）完全依赖于主键，而商品名只依赖于主键的一部分（product_id），就不符合第二范式。

  **不符合**第二范式的设计容易产生冗余数据。

* **第三范式：**在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键形成转递依赖。

  **eg：**考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。

  其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 **CustomerID**（非主键列），而不是直接依赖于主键，它是通过**传递**才依赖于**主键**，所以不符合 3NF。
  通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。

在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。



## MySQL存储引擎

### 1.MyISAM和InnoDB

MyISAM是MySQL 5.5之前的默认数据库引擎，5.5版本之后引入了新的默认数据库引擎。

**两者的对比：**

1.**是否支持行级锁：**MyISAM**只有表级锁**（table-level locking），而InnoDB**支持行级锁**（row-level locking）**和表级锁**，默认为**行级锁**。

2.**是否支持事务和崩溃后的安全恢复**：MyISAM着重强调的是性能，每次查询具有原子性，执行速度比InnoDB更快，但是不提供事务支持。InnoDB提供事务支持、外部键等高级数据库功能，具有事务提交（commit）、回滚（rollback）和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

3.**是否支持外键**：MyISAM不支持，InnoDB支持。

4.对于**查询操作**MyISAM更具有优势，因为其保存了行数。

5.InnoDB是为**处理巨大数据量时的最大性能**设计的存储引擎。

6.**是否支持MVCC**：仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更加高效；MVCC只在` READ COMMITED `和`REPEATABLE READ`两个隔离级别下工作；MVCC可以使用乐观锁和悲观锁来实现，各数据库中MVCC实现并不统一。

一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。

**总结：**

最主要的区别就是MyISAM表支持FULLTEXT类型的全文索引、不支持事务、不支持行级锁、不支持外键。 InnoDB表支持事务、支持行级锁、支持外键。



## 索引

### 1.为什么使用索引（使用索引的好处）？

* 优化查询速度，大大的减少了查询时检索的数据量。
* 帮助MySQL服务器避免排序和临时表（BTree索引是有序的，可以用于order by 和 group by操作）。
* 将磁盘从随机IO变为顺序IO（减少磁盘寻道时间）。

### 2.为什么索引可以提高查询速度？

MySQL的基本存储结构是**页**，记录都存储在页里。

![MySQL的基本存储结构是页](http://q89f682iv.bkt.clouddn.com/blog/20200404/NICuXB9WKwov.jpg)



​	![](http://q89f682iv.bkt.clouddn.com/blog/20200404/fmz0S9k9Uv7a.jpg)

* **每个数据页可以组成一个双向链表**
* **每个数据页中的记录又可以组成一个单向链表**

* **通过主键查找某条记录时会在页目录中使用二分法定位到对应的槽，然后遍历该槽对应分组中的记录链表找到对应的记录**
* 以其他列（非主键）作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。

所以，在不使用索引执行例如 `select * from user where username ='xxx'`这样没有任何优化的sql语句时，默认会执行下列步骤：

1.**定位到记录所在的页（遍历双向链表）**

2.**从所在页中查找对应记录（遍历单项链表）**

上述查询过程时间复杂度近似于**O(logN)**

#### 使用索引的查询过程(以B+Tree索引为例)

![img](http://q89f682iv.bkt.clouddn.com/blog/20200404/AQu5t7MJrKIM.jpg?e=1586001739&token=PHVQrJJVdVeabMFYs6rqWpLrPUXNT5Qk_Y138u2m:qz3kXzRQcK-8_ln_B7yo95fYfE4=)

要找id为8的记录时：

![img](http://q89f682iv.bkt.clouddn.com/blog/20200404/fASBasaM1aNq.jpg?e=1586001802&token=PHVQrJJVdVeabMFYs6rqWpLrPUXNT5Qk_Y138u2m:4tGPfKSaJKV3iMnqv_fYTEyrVv4=)

### 3.MySQL都有那些索引？

索引是在存储引擎层实现的，而非MySQL服务器层，所以**不同的存储引擎具有不同的索引类型和实现。**

#### 1.BTree索引

大多数MySQL存储引擎默认的索引类型。

#### 2.哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。（即必须根据索引的全部列查询才能生效）；

InnoDB 存储引擎有一个特殊的功能叫“**自适应哈希索引**”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 BTree 索引具有哈希索引的一些优点，比如快速的哈希查找。

#### 3.全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

#### 4.空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

### 补充：B树和B+树

* BTREE索引的底层数据结构是B树中的**B+树**，B树即平衡树(Balance Tree)，是一颗查找树，所有的叶子节点在同一层。
* B+树基于B树，但B+树的叶子节点带有指向下一个叶子节点的指针，可以实现叶子节点的顺序查找。
* B树索引的数据全部只在叶子节点中存储，查询更稳定。

#### 数据结构

#### 操作

#### 关联-与红黑树的对比

理论上红黑树也可以用来实现索引，但文件系统和数据库系统普遍选用B+树作为索引的数据结构，主要有以下两个原因：

* **更少的查找次数**

  红黑树的出度为2，B+树的出度通常很大，这意味着同样数据量下红黑树的高度会比B+树大很多，而根据平衡树的特性查找的时间复杂度与树高度有关，所以使用B+树可以得到比使用红黑树更小的查找次数。

* **利用磁盘的预读取特性**

  磁盘IO一次读取的数据量大小是固定的，B+树的出度大、数据都在叶子节点且叶子节点间有指针串联，所以使用B+树做索引可以减少磁盘的IO次数；而红黑树的出度为2，每个父节点仅有两个子节点，一次能读取的数据有限，无疑会大大增加磁盘IO次数，故只有在内存中使用红黑树这种数据结构。

### 4.什么是覆盖索引？优点有哪些？举个适用的场景（包括表结构和查询语句）。

覆盖索引：一个索引中包含所有需要查询字段的值（查询操作只需要访问索引，不需要访问数据行）。

优点：无需回表

1.索引条目通常远小于数据行大小，只需要读取索引，则mysql会极大地减少数据访问量。
2.因为索引是按照列值顺序存储的，所以对于IO密集的范围查找会比随机从磁盘读取每一行数据的IO少很多。
3.一些存储引擎如myisam在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用
4.innodb的聚簇索引，覆盖索引对innodb表特别有用

### 5.索引的适用场景

* 对于非常小的表，一般的全表扫描比建立索引效率更高。
* 对于中到大型表，索引就很有效。
* 对于特大型的表，建立和维护索引的代价将会随着增长，可使用一些技术直接区分出需要查询的一组数据、而不是一条一条的匹配，比如分区技术。

### 6.索引的优化和限制

1. **独立的列**

   在进行查询时，索引列不能是表达式的一部分或函数的参数，例如：

   ```sql
   select * from student where age+1=20;
   ```

   这么写索引是不会生效的。

2. **多列索引**

   在需要多个列来作为查询条件时，使用多列索引比使用多个单列索引效果更好。

3. **索引列的顺序**

   让选择性最强的列放在前面，即区分度最强的列。

4. **最左前缀原则**

   例如在user表中现有一联合索引（指多列组成的索引） （city，name）

   ```sql
   select * from user where city='北京' and name='小明';//可以命中索引
   select * from user where city='北京';//可以命中索引
   select * from user where name='小明' and age=10;//都用上了但顺序不同，MySQL会自动优化，可以命中索引。
   select * from user where name='小明'；//不能命中索引
   ```

5. **前缀索引**

   对BLOB、TEXT、VARCHAR类型的列，必须使用前缀索引，只索引开始部分的字符。

6. **覆盖索引**

   查询包含所需查询的所有字段的值，即数据都在索引里了，查询时只查询到索引就行了。

   具有以下优点：

   * 索引一般小于数据化的大小，只读取索引能大大的减少数据访问量。
   * 因为索引是按顺序存储的，检索索引就从随机IO变为顺序IO了，性能提升很大。
   * 在一些存储引擎(例如MyISAM)中只会在内存中缓存索引，而数据则依赖操作系统来缓存，因此只检索索引可以免于系统调用的耗时。
   * 对于InnoDB，若辅助索引（叶子节点储存了目标行数据的位置）可以覆盖索引，则无需访问主索引。

### 7.使用索引时的注意事项

1. 在经常需要搜索的列上，可以加快搜索的速度；
2. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
3. 在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
4. 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
5. 在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；
6. 避免 where 子句中对宇段施加函数，这会造成无法命中索引。
7. 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
8. 将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描
9. 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用
10. 在使用 limit offset 查询缓慢时，可以借助索引来提高性能

## 事务

### 1.请阐述数据库事务的几大特性，针对数据库事务，以mysql为例，该数据库有几种隔离级别，请阐述每种隔离级别所产生的效果。

#### 事务的四大特性(ACID)：

1. **原子性：**事务是不可分割的，要么全部执行，要么全部不执行。
2. **一致性：**事务执行前后数据的完整性保持一致。
3. **隔离性：**在事务正确提交前，其他事务不能访问该事务的数据。
4. **持久性**：事务一旦提交，对数据库的改动是永久的。

#### MySQL数据库的隔离级别：

SQL标准定义了4个隔离级别：

* **READ-UNCOMMITED（读取未提交）：**最低的隔离级别，允许读取尚未提交的数据变更，**可能导致脏读、幻读、不可重复读。**
* **READ-COMMITED（读取已提交）：**允许读取并发事务已提交的数据变更，**可以阻止脏读，但幻读和不可重复读仍可能发生。**
* **REPEATABLE-READ（可重复读）：**保证对同一字段的多次读取结果是一致的，**可以阻止脏读、不可重复读，但幻读仍有可能发生。**
* **SERIALIZABLE（不可重复读）：** 最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次执行，**可以阻止脏读、幻读、不可重复读**，但执行速度比较慢，实现原理是**完全锁定事务相关的数据库表。**

### 2.并发事务带来的问题

* **脏读：**其他事务修改了该数据还未提交时提前读取了数据。
* **不可重复读：**在一个事务内多次读取同一数据，而在此期间有其他事务对该数据进行了修改，就造成该事务前后读取到的数据不一致。
* **幻读：**与不可重复读类似，在事务T1内读取了几行数据，而另一个事务T2插入了几条新的数据，那么T1就会发现多了几条原本不存在的数据，好像发生幻觉一样，成为幻读。
* **丢失修改：**指事务T1修改数据时，又一事务T2也进行了修改，就造成了事务T1的修改被丢失，例如A = 10，T1执行A-1，同时T2执行A-2，则最后A变成了8。

## MySQL优化

