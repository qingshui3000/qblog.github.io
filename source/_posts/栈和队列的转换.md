---
title: 栈和队列的转换
date: 2019-12-17 23:49:25
tags: 数据结构
	  - 栈
	  - 队列
---

# 用栈实现队列&用队列实现栈问题

## 前言

栈和队列是两种常见的数据结构，简单概括就是栈是“先入后出”的读写规则，队列则遵循“先入先出”的顺序，在理解这些的基础上对于如何使用A实现B的问题就很容易实现了。

<!--more-->

## 一.栈实现队列

### 1.思路分析

首先，队列的基本操作有入队操作`add`、出队操作`pool`和取队首操作`peek`，而按照队列的“先入先出”的规律，我们可以新建一个数据栈data和一个辅助栈help来实现这些操作，`add`时将数据压入data栈即可，例如依次`add`1、2、3、4、5，这时data栈存储情况如下图![stacktoqueue1](/images/stacktoqueue1.png)



假如此时执行`pool`操作，按栈的读取规则得到的是最后入栈、处于栈顶的5，显然是不正确的(应当是最先输入的1)，那么如何得到正确的读取序列呢？其实很简单，还记得刚刚提过的辅助栈吗，我们将data栈内的数据依次弹出直到data栈弹空![stacktoqueue2](/images/stacktoqueue2.png)

这时我们发现，只要对help栈执行出栈操作，即可按正确的顺序输出了。

### 2.完整代码

```java
public class StackToQueue {
    private static Stack<Integer> data;
    private static Stack<Integer> help;

    public StackToQueue(){
        data = new Stack<>();
        help = new Stack<>();
    }

    public static void add(int newNum){
        data.push(newNum);
    }

    public static int peek(){
        if(help.empty()){
            while(!data.empty()){
                int t = data.pop();
                help.push(t);
            }
        }
        return help.peek();
    }

    public static int poll(){
        if(help.empty()){
            while(!data.empty()){
                int t = data.pop();
                help.push(t);
            }
        }
        return help.pop();
    }

    public static void main(String[] args) {
        StackToQueue queue = new StackToQueue();
        queue.add(1);
        queue.add(2);
        queue.add(3);
        System.out.println(queue.poll());
        queue.add(4);
        queue.add(5);
        System.out.println(queue.peek());
    }
}

```





## 二.队列实现栈

### 1.思路分析

首先明确队列和栈的基本操作，如何使用“先入先出”的队列来实现“先入后出”的栈呢？答案与问题一类似，使用两个队列即可。

### 2.完整代码

```java
public class QueueToStack {
    private static Queue<Integer> data;
    private static Queue<Integer> help;

    public QueueToStack(){
        data = new LinkedList<>();
        help = new LinkedList<>();
    }

    public static void push(int newNum){
        data.add(newNum);
    }

    public static int peek(){
        if(data.isEmpty()){
            throw new RuntimeException("empty!");
        }
        while (data.size() > 1){
            help.add(data.poll());
        }
        int res = data.poll();
        swap();
        data.add(res);
        return res;
    }

    public static int pop(){
        if(data.isEmpty()){
            throw new RuntimeException("empty!");
        }
        while (data.size() > 1){
            help.add(data.poll());
        }
        int res = data.poll();
        swap();
        return res;
    }

    private static void swap(){
        Queue<Integer> t = data;
        data = help;
        help = t;
    }


    public static void main(String[] args) {
        QueueToStack stack = new QueueToStack();
        stack.push(1);
        stack.push(2);
        System.out.println(stack.peek());
        stack.push(3);
        System.out.println(stack.pop());
        stack.push(4);
        System.out.println(stack.peek());
        stack.push(5);
    }
}
```



## 三.关联问题--栈的getMin()操作

待更

### 1.思路分析

### 2.完整代码

